 <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Slack Bot Animation - GSAP</title>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/TextPlugin.min.js"></script>
  <style>
    :root {
      --gradient-top-color: #e5e5e5;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      margin: 0;
      padding: 0;
      overflow-y: visible;  /* allow natural vertical growth */
      overflow-x: visible;  /* allow side content (floating cards) to show */
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
      background-color: #E7EDEF;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      min-height: auto;
    }

    .container {
      width: 100%;
      max-width: 100%;
      margin: 0 auto;
      position: relative;
      contain: layout style;
      overflow: visible; /* allow shadows to render fully */
      padding: 0;
      height: fit-content;
    }

    /* Floating Cards */
    .floating-card {
      position: absolute;
      background: white;
      border-radius: 10.917px;
      /* Cheaper shadow while the card is moving */
      box-shadow: 0 10px 20px rgba(0,0,0,0.12);
      padding: 18.06px 22.575px;
      z-index: 50;
      opacity: 0;
      transform: translate3d(0, 100px, 0) scale(0.8);
      will-change: transform, opacity;
      transition: box-shadow 0.4s ease-out;
    }
    
    .floating-card::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 20%;
      background: linear-gradient(to bottom, var(--gradient-top-color), transparent);
      z-index: 1;
      pointer-events: none;
      border-radius: 10.917px 10.917px 0 0;
    }

    .floating-card::after {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(to right, transparent, rgba(255,255,255,0.9), transparent);
      z-index: 30;
      pointer-events: none;
      border-radius: 10.917px 10.917px 0 0;
    }

    /* Apply the heavier shadow only after the card settles */
    .floating-card.shadow-final {
      box-shadow: -13.646px 1.365px 27.293px 0px rgba(0,0,0,0.2);
    }

    .floating-card.right {
      right: 0;
      bottom: 25%;
      width: 300px;
    }

    .floating-card.left {
      left: 0;
      bottom: 15%;
      width: 300px;
    }

    .card-text {
      font-size: 16.141px;
      line-height: 24.832px;
      color: #1d1c1d;
      font-weight: 500;
      margin-bottom: 9.03px;
    }

    #card-right-text,
    #card-left-text {
      font-weight: 400;
    }

    .card-reaction {
      display: flex;
      gap: 9.03px;
      opacity: 0;
    }

    .reaction-bubble {
      background: #f2f2f2;
      border: 1.129px solid #e8e8e8;
      border-radius: 13.545px;
      padding: 4.776px 8.188px;
      display: flex;
      align-items: center;
      gap: 5.459px;
      font-size: 16.376px;
    }

    .reaction-bubble span {
      color: #1d1c1d;
    }

    .card-header {
      display: flex;
      align-items: center;
      gap: 10.917px;
      margin-bottom: 9.03px;
    }

    .card-avatar {
      width: 40.939px;
      height: 40.939px;
      border-radius: 8.188px;
      overflow: hidden;
    }

    .card-avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .card-name {
      font-size: 16.144px;
      font-weight: 700;
      color: #1d1c1d;
    }

    .card-time {
      font-size: 10.917px;
      color: #616061;
    }

    /* Main Window */
    .slack-window {
      width: 860px;
      height: 746px;
      margin: 0 auto;
      background: white;
      border-radius: 20px 20px 0px 0px;
      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
      display: flex;
      overflow: hidden;
      position: relative;
      z-index: 10;
    }

    .slack-window::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 20%;
      background: linear-gradient(to bottom, var(--gradient-top-color), transparent);
      z-index: 10;
      pointer-events: none;
    }

    .slack-window::after {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(to right, transparent, rgba(255,255,255,0.9), transparent);
      z-index: 30;
      pointer-events: none;
    }

    /* Sidebar */
    .sidebar {
      width: 84px;
      background: #4A154B;
      padding: 16px 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      flex-shrink: 0;
      position: relative;
      z-index: 20;
    }

    .sidebar-icon {
      width: 52px;
      height: 52px;
      border-radius: 10px;
      background: rgba(255,255,255,0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      color: rgba(255,255,255,0.7);
    }

    .sidebar-icon svg {
      width: 26px;
      height: 26px;
    }

    .slack-logo {
      width: 42px;
      height: 42px;
      margin-bottom: 10px;
    }

    /* Main Content */
    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-width: 0;
      position: relative;
      z-index: 20;
      padding-bottom: 16px;
    }

    .header {
      background: transparent;
      border-bottom: 1px solid rgba(229, 231, 235, 0.5);
      padding-top: 16px;
      padding-bottom: 16px;
      padding-left: 16px;
      padding-right: 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .header-title {
      font-size: 18px;
      font-weight: 700;
      color: #111827;
    }

    .header-subtitle {
      font-size: 16px;
      font-weight: 600;
      color: #6B7280;
      margin-left: 10px;
    }

    .header-icons {
      display: flex;
      gap: 10px;
      color: #6B7280;
    }

    .header-icons svg {
      width: 20px;
      height: 20px;
    }

    .chat-content {
      padding: 12px;
      position: relative;
      overflow: visible;
      margin-bottom: 16px;
    }
    
    .root-cause-screen.active {
      display: block;
      height: 100%;
      overflow: visible;
    }

    /* Bot Header */
    .bot-header {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
    }

    .bot-avatar {
      width: 42px;
      height: 42px;
      border-radius: 8px;
      overflow: hidden;
      flex-shrink: 0;
      background: linear-gradient(135deg, #C5E3E9, #08363F);
      border: 1px solid #08363F;
      position: relative;
      animation: avatarGlow 3s ease-in-out infinite;
      will-change: box-shadow;
    }

    @keyframes avatarGlow {
      0%, 100% {
        box-shadow: 0 0 0 0 rgba(197, 227, 233, 0.4),
                    0 0 8px 2px rgba(197, 227, 233, 0.2);
      }
      50% {
        box-shadow: 0 0 0 4px rgba(197, 227, 233, 0.1),
                    0 0 16px 4px rgba(197, 227, 233, 0.3);
      }
    }

    .bot-info {
      flex: 1;
    }

    .bot-name {
      font-size: 18px;
      font-weight: 600;
      color: #111827;
      display: inline-block;
    }

    .bot-badge {
      font-size: 16px;
      background: #DBEAFE;
      color: #1E40AF;
      padding: 3px 8px;
      border-radius: 5px;
      margin-left: 10px;
    }

    .bot-time {
      font-size: 16px;
      color: #6B7280;
      margin-left: 10px;
    }

    .bot-status {
      font-size: 16px;
      color: #6B7280;
      margin-top: 3px;
      display: flex;
      align-items: center;
      gap: 8px;
      position: relative;
    }
    
    .bot-status #status-text {
      position: relative;
      background: linear-gradient(90deg, 
        #6B7280 0%, 
        #1F2937 30%, 
        #9CA3AF 50%, 
        #1F2937 70%, 
        #6B7280 100%
      );
      background-size: 300% 100%;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: shimmer 3s ease-in-out infinite;
    }
    
    @keyframes shimmer {
      0% { background-position: -200% 0; }
      50% { background-position: 0% 0; }
      100% { background-position: 200% 0; }
    }

    .loading-dots {
      display: inline-flex;
      gap: 2px;
    }

    .loading-dot {
      width: 5px;
      height: 5px;
      background: #3B82F6;
      border-radius: 50%;
      transition: background-color 0.3s ease;
    }

    .loading-dots.analyzing .loading-dot {
      background: #8B5CF6;
    }

    .loading-dots.complete .loading-dot {
      background: #22C55E;
    }

    /* Dots animation (CSS-driven: cheaper than many GSAP repeat loops) */
    .dots-anim .loading-dot,
    .dots-anim .item-dot {
      opacity: 0.35;
      transform: scale(0.9);
      animation: dotPulse 1.2s ease-in-out infinite;
      will-change: transform, opacity;
    }

    .dots-anim .loading-dot:nth-child(1),
    .dots-anim .item-dot:nth-child(1) { animation-delay: 0s; }

    .dots-anim .loading-dot:nth-child(2),
    .dots-anim .item-dot:nth-child(2) { animation-delay: 0.15s; }

    .dots-anim .loading-dot:nth-child(3),
    .dots-anim .item-dot:nth-child(3) { animation-delay: 0.3s; }

    @keyframes dotPulse {
      0%, 100% { opacity: 0.35; transform: scale(0.9); }
      50%      { opacity: 1;    transform: scale(1.15); }
    }

    /* Items Container */
    .items-container {
      position: relative;
      height: 660px;
      background: white;
      border: 1px solid #F3F4F6;
      border-radius: 5px;
      overflow-y: visible;
      overflow-x: hidden;
      contain: layout style paint;
      will-change: transform;
    }

    .items-container::after {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(
        90deg,
        transparent 0%,
        rgba(59, 130, 246, 0.05) 50%,
        transparent 100%
      );
      transform: translateX(-100%);
      animation: containerShimmer 4s ease-in-out infinite;
      pointer-events: none;
      z-index: 1;
      will-change: transform;
    }

    @keyframes containerShimmer {
      0% { transform: translateX(-100%); }
      50%, 100% { transform: translateX(100%); }
    }

    .items-list {
      position: absolute;
      inset: 0;
      padding: 10px 16px;
      height: 100px;
    }

    .check-item {
      display: flex;
      align-items: center;
      gap: 5px;
      padding: 8px 10px;
      border-radius: 5px;
      margin-bottom: 5px;
      transition: background-color 0.3s;
      opacity: 0;
      transform: translateY(20px);
      will-change: transform, opacity;
    }

    .check-item.waiting { 
      background: #F3F4F6; 
      border: 1px solid #E5E7EB;
    }
    .check-item.fetching { 
      background: #EFF6FF; 
      border: 1px solid #DBEAFE;
    }
    .check-item.analyzing { 
      background: #F5F3FF; 
      border: 1px solid #EDE9FE;
    }
    .check-item.complete { 
      background: #F0FDF4; 
      border: 1px solid #DCFCE7;
    }

    /* One-time pulse animations for each phase */
    .check-item.pulse-fetching {
      animation: fetchingPulse 0.8s ease-out forwards;
    }
    .check-item.pulse-analyzing {
      animation: analyzingPulse 0.8s ease-out forwards;
    }
    .check-item.pulse-complete {
      animation: completePulse 0.8s ease-out forwards;
    }

    @keyframes fetchingPulse {
      0% {
        border-color: #DBEAFE;
        box-shadow: 0 0 0 0 rgba(59, 130, 246, 0);
      }
      50% {
        border-color: rgba(59, 130, 246, 0.8);
        box-shadow: 0 0 12px 2px rgba(59, 130, 246, 0.4);
      }
      100% {
        border-color: #DBEAFE;
        box-shadow: 0 0 0 0 rgba(59, 130, 246, 0);
      }
    }

    @keyframes analyzingPulse {
      0% {
        border-color: #EDE9FE;
        box-shadow: 0 0 0 0 rgba(139, 92, 246, 0);
      }
      50% {
        border-color: rgba(139, 92, 246, 0.8);
        box-shadow: 0 0 12px 2px rgba(139, 92, 246, 0.4);
      }
      100% {
        border-color: #EDE9FE;
        box-shadow: 0 0 0 0 rgba(139, 92, 246, 0);
      }
    }

    @keyframes completePulse {
      0% {
        border-color: #DCFCE7;
        box-shadow: 0 0 0 0 rgba(34, 197, 94, 0);
      }
      50% {
        border-color: rgba(34, 197, 94, 0.8);
        box-shadow: 0 0 12px 2px rgba(34, 197, 94, 0.4);
      }
      100% {
        border-color: #DCFCE7;
        box-shadow: 0 0 0 0 rgba(34, 197, 94, 0);
      }
    }

    .item-label {
      font-weight: 600;
      color: #111827;
      font-size: 14px;
      flex-shrink: 0;
    }

    .check-item.complete .item-label {
      font-size: 17px;
    }

    .item-content {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      min-width: 0;
    }

    .item-status {
      font-size: 14px;
      color: #6B7280;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      flex: 1;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .check-item.complete .item-status {
      font-size: 17px;
      color: #111827;
    }

    .item-star {
      opacity: 0;
      transform: scale(0) rotate(-180deg);
      font-size: 21px;
      display: inline-block;
    }

    .item-button {
      padding: 8px 16px;
      font-size: 16px;
      border: 1px solid #D1D5DB;
      border-radius: 5px;
      background: white;
      font-weight: 600;
      cursor: pointer;
      flex-shrink: 0;
      opacity: 0;
      transform: scale(0.8);
      color: #111827;
    }

    .item-button:hover {
      background: #F9FAFB;
    }

    .item-dots {
      display: flex;
      gap: 4px;
      flex-shrink: 0;
      align-items: center;
    }

    .item-dot {
      width: 5px;
      height: 5px;
      background: #9CA3AF;
      border-radius: 50%;
      animation: dotPulse 1.4s ease-in-out infinite;
    }
    
    .item-dot:nth-child(1) { animation-delay: 0s; }
    .item-dot:nth-child(2) { animation-delay: 0.2s; }
    .item-dot:nth-child(3) { animation-delay: 0.4s; }


    /* Root Cause Screen */
    .root-cause-screen {
      opacity: 0;
      display: none;
    }

    .root-cause-screen.active {
      display: block;
      min-height: 100%;
      padding-bottom: 21px;
    }

    .root-cause-screen .bot-header {
      margin-bottom: 26px;
    }

    .rc-alert {
      font-size: 16px;
      color: #4B5563;
      margin-bottom: 16px;
    }

    .rc-alert-id {
      color: #374151;
    }

    .rc-box {
      background: #F9FAFB;
      border-left: 5px solid #08363F;
      padding: 21px;
      border-radius: 5px;
      margin-bottom: 16px;
      position: relative;
      overflow: hidden;
    }

    .rc-box::after {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(
        120deg,
        rgba(255, 255, 255, 0) 0%,
        rgba(99, 102, 241, 0.12) 40%,
        rgba(16, 185, 129, 0.12) 60%,
        rgba(59, 130, 246, 0.12) 80%,
        rgba(255, 255, 255, 0) 100%
      );
      transform: translateX(-120%);
      opacity: 0;
      pointer-events: none;
    }

    .rc-box.shimmer-once::after {
      animation: rcShimmer 1.6s ease-out forwards;
    }

    @keyframes rcShimmer {
      0% {
        transform: translateX(-120%);
        opacity: 0;
      }
      10% {
        opacity: 1;
      }
      60% {
        opacity: 1;
      }
      100% {
        transform: translateX(120%);
        opacity: 0;
      }
    }

    .rc-title {
      font-size: 18px;
      font-weight: 600;
      color: #111827;
      margin-bottom: 13px;
    }

    .rc-text {
      font-size: 16px;
      color: #374151;
      line-height: 1.6;
    }

    .rc-text code {
      background: #E5E7EB;
      padding: 3px 5px;
      border-radius: 3px;
      font-size: 16px;
    }

    .rc-button {
      background: #0D9488;
      color: white;
      padding: 8px 16px;
      border-radius: 5px;
      border: none;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      margin-bottom: 16px;
    }

    .rc-button:hover {
      background: #0F766E;
    }

    .rc-items {
      margin-bottom: 16px;
    }

    .rc-item {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 16px;
      margin-bottom: 10px;
    }

    .rc-item-label {
      font-weight: 600;
      color: #111827;
    }

    .rc-item-content {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .rc-item-text {
      color: #111827;
      flex: 1;
    }
    
    .rc-item-text .star-emoji {
      font-size: 21px;
      display: inline-block;
      margin-left: 5px;
    }

    .rc-actions {
      display: flex;
      gap: 10px;
      margin-bottom: 16px;
    }

    .rc-action-btn {
      padding: 8px 16px;
      border: 1px solid #D1D5DB;
      border-radius: 5px;
      background: white;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      color: #111827;
    }

    .rc-action-btn:hover {
      background: #F9FAFB;
    }

    .rc-feedback {
      display: flex;
      gap: 10px;
      margin-bottom: 0;
    }

    .rc-feedback-btn {
      padding: 5px 10px;
      border: 1px solid #D1D5DB;
      border-radius: 5px;
      background: white;
      font-size: 16px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 5px;
      color: #111827;
    }

    .rc-feedback-btn:hover {
      background: #F9FAFB;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Right Floating Card -->
    <div class="floating-card right" id="card-right">
      <div class="card-header">
        <div class="card-avatar">
          <img src="https://images.unsplash.com/photo-1472099645785-5658abf4ff4e?w=100&h=100&fit=crop" alt="Avatar">
        </div>
        <div>
          <div class="card-name">marcus</div>
          <div class="card-time">Aug 25th at 9:45 AM</div>
        </div>
      </div>
      <div class="card-text">
        <span id="card-right-text">Wow! It's very impressive that it got it right that time</span>
      </div>
      <div class="card-reaction" id="card-right-reaction">
        <div class="reaction-bubble">
          <span>üëç</span>
          <span style="font-weight: 600; font-size: 10.917px;">2</span>
        </div>
      </div>
    </div>

    <!-- Left Floating Card -->
    <div class="floating-card left" id="card-left">
      <div class="card-header">
        <div class="card-avatar">
          <img src="https://images.unsplash.com/photo-1494790108377-be9c29b29330?w=100&h=100&fit=crop" alt="Avatar">
        </div>
        <div>
          <div class="card-name">sarah</div>
          <div class="card-time">Aug 25th at 9:42 AM</div>
        </div>
      </div>
      <div class="card-text">
        <span id="card-left-text">Wow, there was barely any evidence to work with.</span>
      </div>
      <div class="card-reaction" id="card-left-reaction">
        <div class="reaction-bubble">
          <span>üòÆ</span>
          <span style="font-weight: 600; font-size: 10.917px;">1</span>
        </div>
        <div class="reaction-bubble">
          <span>üéØ</span>
        </div>
      </div>
    </div>

    <!-- Main Slack Window -->
    <div class="slack-window">
      <!-- Sidebar -->
      <div class="sidebar">
        <div class="slack-logo">
          <svg viewBox="0 0 50 50" fill="none">
            <path d="M18.1892 10.3714C15.3213 10.3714 13.0035 8.05352 13.0035 5.18568C13.0035 2.31784 15.3213 0 18.1892 0C21.057 0 23.3748 2.31784 23.3748 5.18568V10.3714H18.1892ZM18.1892 13.0035C21.057 13.0035 23.3748 15.3213 23.3748 18.1892C23.3748 21.057 21.057 23.3748 18.1892 23.3748H5.18568C2.31784 23.3748 0 21.057 0 18.1892C0 15.3213 2.31784 13.0035 5.18568 13.0035H18.1892Z" fill="#36C5F0"/>
            <path d="M38.9712 18.1892C38.9712 15.3213 41.289 13.0035 44.1569 13.0035C47.0247 13.0035 49.3425 15.3213 49.3425 18.1892C49.3425 21.057 47.0247 23.3748 44.1569 23.3748H38.9712V18.1892ZM36.3783 18.1892C36.3783 21.057 34.0605 23.3748 31.1927 23.3748C28.3248 23.3748 26.007 21.057 26.007 18.1892V5.18568C26.007 2.31784 28.3248 2.85901e-06 31.1927 2.85901e-06C34.0605 2.85901e-06 36.3783 2.31784 36.3783 5.18568V18.1892Z" fill="#2EB67D"/>
            <path d="M10.4107 31.1926C10.4107 34.0604 8.09289 36.3783 5.22505 36.3783C2.35721 36.3783 0.0393729 34.0604 0.0393729 31.1926C0.0393729 28.3247 2.35721 26.0069 5.22505 26.0069H10.4107V31.1926ZM13.0036 31.1926C13.0036 28.3247 15.3214 26.0069 18.1893 26.0069C21.0571 26.0069 23.3749 28.3247 23.3749 31.1926V44.1568C23.3749 47.0246 21.0571 49.3425 18.1893 49.3425C15.3214 49.3425 13.0036 47.0246 13.0036 44.1568V31.1926Z" fill="#E01E5A"/>
            <path d="M31.1927 38.9711C34.0605 38.9711 36.3783 41.289 36.3783 44.1568C36.3783 47.0246 34.0605 49.3425 31.1927 49.3425C28.3248 49.3425 26.007 47.0246 26.007 44.1568V38.9711H31.1927ZM31.1927 36.3783C28.3248 36.3783 26.007 34.0604 26.007 31.1926C26.007 28.3247 28.3248 26.0069 31.1927 26.0069H44.1961C47.064 26.0069 49.3818 28.3247 49.3818 31.1926C49.3818 34.0604 47.064 36.3783 44.1961 36.3783H31.1927Z" fill="#ECB22E"/>
          </svg>
        </div>
        <div class="sidebar-icon">
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 20l4-16m2 16l4-16M6 9h14M4 15h14"></path></svg>
        </div>
        <div class="sidebar-icon">
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"></path></svg>
        </div>
        <div class="sidebar-icon">
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197M13 7a4 4 0 11-8 0 4 4 0 018 0z"></path></svg>
        </div>
        <div class="sidebar-icon">
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 5a2 2 0 012-2h10a2 2 0 012 2v16l-7-3.5L5 21V5z"></path></svg>
        </div>
      </div>

      <!-- Main Content -->
      <div class="main-content">
        <!-- Header -->
        <div class="header">
          <div>
            <span class="header-title">Thread</span>
            <span class="header-subtitle">Wild Moose (Dev)</span>
          </div>
          <div class="header-icons">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"></path></svg>
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9"></path></svg>
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
          </div>
        </div>

        <!-- Chat Content -->
        <div class="chat-content">
          <!-- Processing View -->
          <div id="processing-view">
            <div class="bot-header">
              <div class="bot-avatar">
                <img src="wildmoose-avatar.png" alt="Wild Moose" style="width: 100%; height: 100%; object-fit: cover; border-radius: 6px;">
              </div>
              <div class="bot-info">
                <div>
                  <span class="bot-name">Wild Moose (Dev)</span>
                  <span class="bot-badge">APP</span>
                  <span class="bot-time">Just now</span>
                </div>
                <div class="bot-status">
                  <div class="loading-dots" id="status-dots">
                    <div class="loading-dot"></div>
                    <div class="loading-dot"></div>
                    <div class="loading-dot"></div>
                  </div>
                  <span id="status-text">Collecting evidence from data sources</span>
                </div>
              </div>
            </div>

            <div class="items-container">
              <div class="items-list" id="items-list"></div>
            </div>
          </div>

          <!-- Root Cause View -->
          <div id="root-cause-view" class="root-cause-screen">
            <div class="bot-header">
              <div class="bot-avatar">
                <img src="wildmoose-avatar.png" alt="Wild Moose" style="width: 100%; height: 100%; object-fit: cover; border-radius: 6px;">
              </div>
              <div class="bot-info">
                <div>
                  <span class="bot-name">Wild Moose (Dev)</span>
                  <span class="bot-badge">APP</span>
                  <span class="bot-time">1 minute ago</span>
                </div>
                <div class="bot-status">
                  <span>Alert Enrichment Ready</span>
                </div>
              </div>
            </div>

            <div class="rc-alert">
              For alert: <span class="rc-alert-id">#66515: [Grafana]: SLO response time PlatformMetadataService getProviderDataById com.wixpress.payment.payment-metadata-web</span>
            </div>

            <div class="rc-box">
              <div class="rc-title">Root Cause:</div>
              <div class="rc-text">
                The latency spike for <code>getProviderData</code> in <code>payment-web</code> is isolated to <code>us-west-2</code> and driven by population service timeouts which cascade to higher response times. The population service experienced a 340% increase in <code>DeadlineExceededException</code> errors during HPA pod warmup, causing cascading failures to <code>payment-web</code>.
              </div>
            </div>

            <button class="rc-button">Scale payment-web</button>

            <div class="rc-items" id="rc-items"></div>

            <div class="rc-actions">
              <button class="rc-action-btn">Run Again</button>
              <button class="rc-action-btn">Re-analyze</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Ensure the text plugin is available for typewriter effects
    if (window.gsap && window.TextPlugin) {
      gsap.registerPlugin(TextPlugin);
    }

    const TOTAL_ITEMS = 18;
    const itemLabels = [
      'War room threads',
      'Lost quorum (specific/all DCs?)',
      'Failing health checks',
      'DC switch',
      'Top exception',
      'Errors Sample request ID',
      'Source of error',
      'Cascading errors sequence',
      'Stack trace analysis',
      'Caller Distribution',
      'p50 vs p95, WEB vs KAFKA vs SERVER',
      "Exception's frequency anomalies",
      'Traffic (RPM) increase',
      'DB query RPM anomalies',
      'Misbehaving pod anomalies',
      'Recent deployments',
      'Config changes',
      'Memory usage patterns',
    ];

    const itemResults = [
      'None',
      'No.',
      'No failing health checks detected in the last 30 minutes.',
      'No DC switch detected in the 30 minutes before the alert.',
      'DeadlineExceededException at getProviderDataById',
      'req_abc123xyz789',
      'Population service timeout cascading to payment-web',
      'Payment-web ‚Üí Population-service ‚Üí Database timeout',
      'Exception originates from population service HPA pod warmup',
      'Evenly distributed across all callers',
      'p95 spike isolated to SERVER calls in us-west-2',
      'Frequency increased 340% in last 15 minutes',
      'RPM increased 25% coinciding with new pod scaling',
      'Query timeout spike for getUserPopulation in us-west-2',
      'Uneven heap memory usage detected in newly scaled pods',
      'No deployments in the last 2 hours',
      'No configuration changes detected',
      'Memory pressure on 3 out of 8 pods in us-west-2',
    ];

    // Add more random stars - original 5 plus 3 more random ones
    const starredItems = [1, 4, 6, 11, 14, 2, 9, 16];

    const cardMessages = {
      right: "Wow! It's very impressive that it got it right that time",
      left: "Wow, there was barely any evidence to work with."
    };
    
    // Data sources for fetching phase
    const dataSources = ['logs', 'metrics', 'traces'];
    const itemDataSources = {}; // Store which source each item is fetching from

    let mainTimeline;
    const itemElements = [];
    
    // Cache DOM elements for performance
    const elements = {
      itemsList: null,
      processingView: null,
      rootCauseView: null,
      statusText: null,
      cardRight: null,
      cardLeft: null,
      cardRightText: null,
      cardLeftText: null,
      cardRightReaction: null,
      cardLeftReaction: null,
      rcItems: null
    };

    function typeText(element, text, duration = 2) {
      const tl = gsap.timeline();
      tl.to(element, {
        duration: duration,
        text: text,
        ease: "none"
      });
      return tl;
    }

    function animateLoadingDots() {
      const statusDots = document.getElementById('status-dots');
      if (statusDots) statusDots.classList.add('dots-anim');
    }

    function animateItemDots(itemEl) {
      const dotsContainer = itemEl?.querySelector?.('.item-dots');
      if (dotsContainer) dotsContainer.classList.add('dots-anim');
    }
    
    function cleanupAnimations() {
      itemDotsAnimations = [];
      loadingDotsAnimation = null;

      if (mainTimeline) {
        mainTimeline.kill();
        mainTimeline = null;
      }
    }

    function setDotsActive(active) {
      const statusDots = document.getElementById('status-dots');
      const processingView = document.getElementById('processing-view');
      const processingVisible = processingView && window.getComputedStyle(processingView).display !== 'none' && window.getComputedStyle(processingView).opacity !== '0';
      if (statusDots) {
        if (active && processingVisible) {
          statusDots.classList.add('dots-anim');
        } else {
          statusDots.classList.remove('dots-anim');
        }
      }

      const itemDots = document.querySelectorAll('.item-dots');
      itemDots.forEach((el) => {
        if (!active) {
          el.classList.remove('dots-anim');
          return;
        }
        const style = window.getComputedStyle(el);
        if (style.display !== 'none' && style.visibility !== 'hidden' && style.opacity !== '0') {
          el.classList.add('dots-anim');
        }
      });
    }

    let visibilityControlsInitialized = false;
    let embedIsInView = true;

    function checkInitialVisibility() {
      // Synchronous check: is the embed actually visible on page load?
      const target = document.querySelector('.container') || document.querySelector('.slack-window');
      if (!target) return true; // Default to visible if we can't find it
      
      const rect = target.getBoundingClientRect();
      const viewportHeight = window.innerHeight || document.documentElement.clientHeight;
      // Consider visible if any part is in the viewport (or just below it, since it's "just after fold")
      return rect.top < viewportHeight + 200; // 200px buffer for "just after fold"
    }

    function setupVisibilityControls() {
      if (visibilityControlsInitialized) return;
      visibilityControlsInitialized = true;

      // Observe the whole embed; since it's below the fold, pause when offscreen.
      const target = document.querySelector('.container') || document.querySelector('.slack-window');
      if (!target) {
        // If we can't find the target, just set embedIsInView to true and continue
        embedIsInView = true;
        return;
      }

      const pauseAll = () => {
        if (mainTimeline) {
          mainTimeline.pause();
        }
        setDotsActive(false);
      };

      const resumeAll = () => {
        if (document.hidden) return;
        if (!embedIsInView) return;
        if (mainTimeline) {
          mainTimeline.resume();
        }
        // Only re-enable dots for currently-visible dot containers
        setDotsActive(true);
      };

      const observer = new IntersectionObserver(
        (entries) => {
          embedIsInView = !!entries[0]?.isIntersecting;
          if (!embedIsInView) {
            pauseAll();
          } else {
            resumeAll();
          }
        },
        { threshold: 0.1, rootMargin: '100px' } // More lenient: start animating when close to viewport
      );

      observer.observe(target);

      // Set initial state based on synchronous check
      embedIsInView = checkInitialVisibility();

      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          pauseAll();
        } else {
          resumeAll();
        }
      });
    }

    function createCheckItem(index) {
      const item = document.createElement('div');
      item.className = 'check-item waiting';
      item.id = `item-${index}`;
      item.innerHTML = `
        <span class="item-label">${itemLabels[index]}:</span>
        <div class="item-content">
          <div class="item-status">
            <span class="status-text">Waiting for dependencies</span>
            <div class="item-dots">
              <div class="item-dot"></div>
              <div class="item-dot"></div>
              <div class="item-dot"></div>
            </div>
            <span class="item-star">${starredItems.includes(index) ? '‚≠ê' : ''}</span>
          </div>
          <button class="item-button">See more</button>
          <svg class="item-more" width="12" height="12" fill="none" stroke="#9CA3AF" viewBox="0 0 24 24">
            <circle cx="12" cy="12" r="1"></circle>
            <circle cx="19" cy="12" r="1"></circle>
            <circle cx="5" cy="12" r="1"></circle>
          </svg>
        </div>
      `;
      return item;
    }

    function cacheElements() {
      if (elements.itemsList) return;
      elements.itemsList = document.getElementById('items-list');
      elements.processingView = document.getElementById('processing-view');
      elements.rootCauseView = document.getElementById('root-cause-view');
      elements.statusText = document.getElementById('status-text');
      elements.cardRight = document.getElementById('card-right');
      elements.cardLeft = document.getElementById('card-left');
      elements.cardRightText = document.getElementById('card-right-text');
      elements.cardLeftText = document.getElementById('card-left-text');
      elements.cardRightReaction = document.getElementById('card-right-reaction');
      elements.cardLeftReaction = document.getElementById('card-left-reaction');
      elements.rcItems = document.getElementById('rc-items');
    }

    // Ensure cards reserve their final height so the type animation doesn't grow them
    function setCardBaseHeights() {
      if (!elements.cardRight || !elements.cardLeft) return;
      
      // Cards have text pre-filled, so we can measure their natural height
      const rightHeight = elements.cardRight.offsetHeight;
      const leftHeight = elements.cardLeft.offsetHeight;
      
      // Lock the height so typing doesn't cause growth
      if (rightHeight) {
        elements.cardRight.style.height = `${rightHeight}px`;
      }
      if (leftHeight) {
        elements.cardLeft.style.height = `${leftHeight}px`;
      }
    }

    function updateMinHeight() {
      const container = document.querySelector('.container');
      if (!container) return;

      const bodyStyle = window.getComputedStyle(document.body);
      const paddingTop = parseFloat(bodyStyle.paddingTop) || 0;
      const paddingBottom = parseFloat(bodyStyle.paddingBottom) || 0;
      const contentHeight = container.offsetHeight + paddingTop + paddingBottom;
      const minHeight = Math.max(contentHeight, window.innerHeight);

      document.body.style.minHeight = `${minHeight}px`;
      document.documentElement.style.height = 'auto';
    }

    function buildStaticItems() {
      if (!elements.itemsList || itemElements.length) return;
      const fragment = document.createDocumentFragment();
      for (let i = 0; i < TOTAL_ITEMS; i++) {
        const item = createCheckItem(i);
        fragment.appendChild(item);
        itemElements.push({
          index: i,
          root: item,
          status: item.querySelector('.status-text'),
          dots: item.querySelector('.item-dots'),
          star: item.querySelector('.item-star'),
          button: item.querySelector('.item-button'),
          more: item.querySelector('.item-more'),
        });
      }
      elements.itemsList.appendChild(fragment);
    }

    function buildRootCauseStatic() {
      if (!elements.rcItems || elements.rcItems.childElementCount) return;
      const fragment = document.createDocumentFragment();
      for (let i = 0; i < 4; i++) {
        const item = document.createElement('div');
        item.className = 'rc-item';
        item.innerHTML = `
          <span class="rc-item-label">${itemLabels[i]}:</span>
          <div class="rc-item-content">
            <span class="rc-item-text">${itemResults[i]}${starredItems.includes(i) ? '<span class="star-emoji">‚≠ê</span>' : ''}</span>
            <button class="item-button">See more</button>
          </div>
        `;
        fragment.appendChild(item);
      }
      elements.rcItems.appendChild(fragment);
    }

    function resetItemState(item, phase = 'waiting') {
      // Remove any existing pulse classes first
      item.root.classList.remove('pulse-fetching', 'pulse-analyzing', 'pulse-complete');
      item.root.className = `check-item ${phase}`;
      
      // Trigger one-shot pulse animation for phase transitions
      // Force reflow to ensure animation restarts
      if (phase === 'fetching') {
        void item.root.offsetWidth;
        item.root.classList.add('pulse-fetching');
        setTimeout(() => item.root.classList.remove('pulse-fetching'), 800);
      } else if (phase === 'analyzing') {
        void item.root.offsetWidth;
        item.root.classList.add('pulse-analyzing');
        setTimeout(() => item.root.classList.remove('pulse-analyzing'), 800);
      } else if (phase === 'complete') {
        void item.root.offsetWidth;
        item.root.classList.add('pulse-complete');
        setTimeout(() => item.root.classList.remove('pulse-complete'), 800);
      }

      if (item.status) {
        // Strong status change: old scales up and fades out, new scales down and fades in
        const oldText = item.status.textContent;
        let newText = '';
        if (phase === 'waiting') newText = 'Waiting for dependencies';
        else if (phase === 'fetching') {
          // Assign a random data source for this item if not already assigned
          if (!itemDataSources[item.index]) {
            itemDataSources[item.index] = dataSources[Math.floor(Math.random() * dataSources.length)];
          }
          newText = `Fetching ${itemDataSources[item.index]}`;
        }
        else if (phase === 'analyzing') newText = 'Analyzing result';
        else if (phase === 'complete') newText = itemResults[item.index];
        
        if (oldText !== newText && newText) {
          // Old status: scale up and fade out
          gsap.to(item.status, {
            scale: 1.3,
            opacity: 0,
            duration: 0.2,
            ease: 'power2.out',
            force3D: true,
            onComplete: () => {
              // Change text and set new status to start scaled down and invisible
              item.status.textContent = newText;
              gsap.set(item.status, { scale: 0.7, opacity: 0, force3D: true });
              // New status: scale down to normal and fade in
              gsap.to(item.status, {
                scale: 1,
                opacity: 1,
                duration: 0.25,
                ease: 'back.out(1.4)',
                force3D: true
              });
            }
          });
        } else {
          item.status.textContent = newText;
        }
      }

      if (item.dots) {
        item.dots.style.display = phase === 'complete' ? 'none' : 'flex';
        if (phase !== 'complete') animateItemDots(item.root);
      }

      if (item.button) {
        if (phase === 'complete') {
          gsap.to(item.button, {
            opacity: 1,
            scale: 1,
            duration: 0.2,
            ease: 'back.out(1.2)',
            force3D: true
          });
        } else {
          gsap.set(item.button, { opacity: 0, scale: 0.85, force3D: true });
        }
      }

      if (item.star) {
        if (phase === 'complete' && starredItems.includes(item.index)) {
          gsap.to(item.star, {
            opacity: 1,
            scale: 1,
            rotation: 0,
            duration: 0.25,
            ease: 'back.out(1.5)',
            force3D: true
          });
        } else {
          gsap.set(item.star, { opacity: 0, scale: 0, rotation: 0, force3D: true });
        }
      }

      if (item.more) {
        item.more.style.display = phase === 'complete' ? 'none' : 'inline';
      }
    }

    function resetAllState() {
      processedCount = 0;
      
      // Clear data source assignments for fresh randomization
      Object.keys(itemDataSources).forEach((key) => delete itemDataSources[key]);

      elements.processingView.style.display = 'block';
      gsap.set(elements.processingView, { opacity: 1, force3D: true });
      
      // Ensure bot header in processing view stays visible (persists across states)
      const processingBotHeader = elements.processingView?.querySelector('.bot-header');
      if (processingBotHeader) {
        gsap.set(processingBotHeader, { opacity: 1, y: 0, force3D: true });
      }
      
      elements.rootCauseView.classList.remove('active');
      elements.rootCauseView.style.display = 'none';
      gsap.set(elements.rootCauseView, { opacity: 0, force3D: true });
      
      // Ensure bot header in root cause view stays visible (persists across states)
      const rcBotHeader = elements.rootCauseView?.querySelector('.bot-header');
      if (rcBotHeader) {
        gsap.set(rcBotHeader, { opacity: 1, y: 0, force3D: true });
      }
      
      // Reset other root cause content children opacity
      if (elements.rootCauseView) {
        const rcAlert = elements.rootCauseView.querySelector('.rc-alert');
        const rcBox = elements.rootCauseView.querySelector('.rc-box');
        const rcButton = elements.rootCauseView.querySelector('.rc-button');
        const rcItems = elements.rootCauseView.querySelector('.rc-items');
        const rcActions = elements.rootCauseView.querySelector('.rc-actions');
        
        // Set content to invisible (rcItems container stays visible, children animate)
        [rcAlert, rcBox, rcButton, rcActions].forEach(el => {
          if (el) gsap.set(el, { opacity: 0, y: 8, force3D: true });
        });
        if (rcBox) {
          rcBox.classList.remove('shimmer-once');
        }
        // rcItems container visible, but its children start invisible
        if (rcItems) {
          gsap.set(rcItems, { opacity: 1, y: 0, force3D: true });
          const rcItemElements = rcItems.querySelectorAll('.rc-item');
          rcItemElements.forEach(item => {
            gsap.set(item, { opacity: 0, y: 8, force3D: true });
          });
        }
      }

      elements.statusText.textContent = 'Collecting evidence from data sources';
      const statusDots = document.getElementById('status-dots');
      if (statusDots) {
        statusDots.classList.remove('analyzing', 'complete');
      }

      if (elements.cardRight) {
        elements.cardRight.classList.remove('shadow-final');
        gsap.set(elements.cardRight, { opacity: 0, scale: 0.9, y: 80, rotation: 0, force3D: true });
        if (elements.cardRightText) {
          elements.cardRightText.textContent = '';
          gsap.set(elements.cardRightText, { opacity: 1 });
        }
        // Hide card header initially
        const cardRightHeader = elements.cardRight.querySelector('.card-header');
        if (cardRightHeader) {
          gsap.set(cardRightHeader, { opacity: 0, y: -10 });
        }
      }
      if (elements.cardLeft) {
        elements.cardLeft.classList.remove('shadow-final');
        gsap.set(elements.cardLeft, { opacity: 0, scale: 0.9, y: 80, rotation: 0, force3D: true });
        if (elements.cardLeftText) {
          elements.cardLeftText.textContent = '';
          gsap.set(elements.cardLeftText, { opacity: 1 });
        }
        // Hide card header initially
        const cardHeader = elements.cardLeft.querySelector('.card-header');
        if (cardHeader) {
          gsap.set(cardHeader, { opacity: 0, y: -10 });
        }
      }
      if (elements.cardRightReaction) gsap.set(elements.cardRightReaction, { opacity: 0 });
      if (elements.cardLeftReaction) gsap.set(elements.cardLeftReaction, { opacity: 0 });

      itemElements.forEach((item) => {
        // Clear any inline animation and pulse classes from previous cycle
        item.root.style.animation = '';
        item.root.classList.remove('pulse-fetching', 'pulse-analyzing', 'pulse-complete');
        
        gsap.set(item.root, { opacity: 0, y: 20, scale: 1.15, force3D: true });
        if (item.status) {
          gsap.set(item.status, { scale: 1, opacity: 1, force3D: true });
        }
        resetItemState(item, 'waiting');
      });
    }

    function runAnimation() {
      cleanupAnimations();
      cacheElements();
      buildStaticItems();
      buildRootCauseStatic();
      setCardBaseHeights();
      updateMinHeight();
      resetAllState();
      animateLoadingDots();
      
      // Ensure dots are active at start
      setDotsActive(true);

      mainTimeline = gsap.timeline({
        defaults: { force3D: true },
        repeat: -1,
        repeatDelay: 0.5,
        onRepeat: () => {
          resetAllState();
          animateLoadingDots();
          setDotsActive(true);
        }
      });

      if (document.hidden || !embedIsInView) {
        mainTimeline.pause(0);
        setDotsActive(false);
      }

      // Phase 1: reveal items with stagger and scale-down effect
      itemElements.forEach((item, i) => {
        gsap.set(item.root, { scale: 1.15, force3D: true });
      });
      mainTimeline.to(itemElements.map((i) => i.root), {
        opacity: 1,
        y: 0,
        scale: 1,
        duration: 0.3,
        stagger: 0.1,
        ease: 'back.out(1.1)',
      }, 0);

      // Helper function to shuffle array (Fisher-Yates)
      function shuffleArray(array) {
        const shuffled = [...array];
        for (let i = shuffled.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        return shuffled;
      }

      // Phase 2: switch to fetching - start EARLY while grays are still loading
      // Use ABSOLUTE time positions so blues appear while grays are still animating
      const allIndices = itemElements.map((_, i) => i);
      const topVisibleIndices = [0, 1, 2]; // First 3 items are always visible
      const firstBlueIndex = topVisibleIndices[Math.floor(Math.random() * topVisibleIndices.length)];
      const secondBlueIndex = topVisibleIndices.filter(i => i !== firstBlueIndex)[Math.floor(Math.random() * (topVisibleIndices.length - 1))];
      const remainingIndices = allIndices.filter(i => i !== firstBlueIndex && i !== secondBlueIndex);
      const shuffledRemaining = shuffleArray(remainingIndices);
      const fetchingOrder = [firstBlueIndex, secondBlueIndex, ...shuffledRemaining];
      
      // First few blues come in slowly, then rest come rapidly
      let blueTime = 0.5; // Start first blue at 0.5s absolute
      fetchingOrder.forEach((itemIndex, orderIndex) => {
        const time = blueTime;
        mainTimeline.call(() => {
          resetItemState(itemElements[itemIndex], 'fetching');
        }, null, time);
        
        // Slower for first 4, then rapid for the rest
        if (orderIndex < 4) {
          blueTime += 0.25 + Math.random() * 0.15; // Slower: 0.25-0.4s gaps
        } else {
          blueTime += 0.06 + Math.random() * 0.08; // Rapid: 0.06-0.14s gaps
        }
      });

      // Phase 3: switch to analyzing with randomized order
      mainTimeline.call(() => {
        elements.statusText.textContent = 'Analyzing data from enrichment sources';
        const statusDots = document.getElementById('status-dots');
        if (statusDots) {
          statusDots.classList.remove('complete');
          statusDots.classList.add('analyzing');
        }
      }, null, '+=0.4');

      const analyzingOrder = shuffleArray(itemElements.map((_, i) => i));
      analyzingOrder.forEach((itemIndex, orderIndex) => {
        const delay = orderIndex === 0 ? 0.2 : 0.06 + Math.random() * 0.12;
        mainTimeline.call(() => {
          resetItemState(itemElements[itemIndex], 'analyzing');
        }, null, `+=${delay}`);
      });

      // Phase 4: complete items + progress with randomized order
      mainTimeline.call(() => {
        elements.statusText.textContent = 'Alert Enrichment Ready';
        const statusDots = document.getElementById('status-dots');
        if (statusDots) {
          statusDots.classList.remove('analyzing');
          statusDots.classList.add('complete');
        }
      }, null, '+=0.4');

      const completeOrder = shuffleArray(itemElements.map((_, i) => i));
      completeOrder.forEach((itemIndex, orderIndex) => {
        const delay = orderIndex === 0 ? 0.25 : 0.1 + Math.random() * 0.15;
        mainTimeline.call(() => {
          resetItemState(itemElements[itemIndex], 'complete');
        }, null, `+=${delay}`);
      });

      // Phase 5: show root cause screen
      // Query elements before transition (they exist in DOM, just hidden)
      const rcBotHeader = elements.rootCauseView.querySelector('.bot-header');
      const rcAlert = elements.rootCauseView.querySelector('.rc-alert');
      const rcBox = elements.rootCauseView.querySelector('.rc-box');
      const rcButton = elements.rootCauseView.querySelector('.rc-button');
      const rcItems = elements.rootCauseView.querySelector('.rc-items');
      const rcActions = elements.rootCauseView.querySelector('.rc-actions');
      
      mainTimeline.to(elements.processingView, {
        opacity: 0,
        duration: 0.45,
        ease: 'power1.out',
        onComplete: () => {
          setDotsActive(false);
          elements.processingView.style.display = 'none';
          
          elements.rootCauseView.classList.add('active');
          elements.rootCauseView.style.display = 'block';
          gsap.set(elements.rootCauseView, { opacity: 1, force3D: true });
          
          // Bot header stays visible - no animation needed, it persists
          if (rcBotHeader) {
            gsap.set(rcBotHeader, { opacity: 1, y: 0, force3D: true });
          }
          
          // Set all content (except bot header) to invisible initially
          // Note: rcItems container stays visible, only its children animate
          [rcAlert, rcBox, rcButton, rcActions].forEach(el => {
            if (el) gsap.set(el, { opacity: 0, y: 8, force3D: true });
          });
          // Ensure rc-items are built and visible, but children start invisible
          buildRootCauseStatic();
          if (rcItems) {
            gsap.set(rcItems, { opacity: 1, y: 0, force3D: true });
            const rcItemElements = rcItems.querySelectorAll('.rc-item');
            rcItemElements.forEach(item => {
              gsap.set(item, { opacity: 0, y: 8, force3D: true });
            });
          }
        }
      }, "+=0.6");

      // Phase 6: cascade in root cause content - wave effect with heavy overlap
      // Start each next element before previous finishes for wave effect
      if (rcAlert) {
        mainTimeline.to(rcAlert, {
          opacity: 1,
          y: 0,
          duration: 0.25,
          ease: 'power1.out'
        }, "+=0.1");
      }
      
      if (rcBox) {
        // Trigger shimmer once as it comes in
        mainTimeline.call(() => {
          rcBox.classList.remove('shimmer-once'); // reset in case
          rcBox.classList.add('shimmer-once');
        }, null, "-=0.22");
        mainTimeline.to(rcBox, {
          opacity: 1,
          y: 0,
          duration: 0.25,
          ease: 'power1.out'
        }, "-=0.12"); // Start 0.12s before rcAlert finishes (0.25 - 0.12 = overlap)
      }
      
      if (rcButton) {
        mainTimeline.to(rcButton, {
          opacity: 1,
          y: 0,
          duration: 0.25,
          ease: 'power1.out'
        }, "-=0.12"); // Start before rcBox finishes
      }
      
      if (rcItems) {
        const rcItemElements = rcItems.querySelectorAll('.rc-item');
        if (rcItemElements.length > 0) {
          rcItemElements.forEach(item => {
            gsap.set(item, { scale: 0.95, force3D: true });
          });
          mainTimeline.to(rcItemElements, {
            opacity: 1,
            y: 0,
            scale: 1,
            duration: 0.25,
            stagger: 0.02,
            ease: 'back.out(1.1)'
          }, "-=0.12"); // Start before rcButton finishes
        } else {
          // If items haven't been built yet, ensure they're built and visible
          buildRootCauseStatic();
          const rcItemElementsAfter = rcItems.querySelectorAll('.rc-item');
          if (rcItemElementsAfter.length > 0) {
            rcItemElementsAfter.forEach(item => {
              gsap.set(item, { opacity: 0, y: 8, scale: 0.95, force3D: true });
            });
            mainTimeline.to(rcItemElementsAfter, {
              opacity: 1,
              y: 0,
              scale: 1,
              duration: 0.25,
              stagger: 0.02,
              ease: 'back.out(1.1)'
            }, "-=0.12");
          }
        }
      }
      
      if (rcActions) {
        mainTimeline.to(rcActions, {
          opacity: 1,
          y: 0,
          duration: 0.25,
          ease: 'power1.out'
        }, "-=0.12"); // Start before rcItems finish
      }

      // Phase 7: first card (right card) - start almost immediately after last rc-item
      mainTimeline.to(elements.cardRight, {
        opacity: 1,
        scale: 1,
        y: 0,
        rotation: 3,
        duration: 0.7,
        ease: "back.out(1.2)",
        onComplete: () => elements.cardRight.classList.add('shadow-final')
      }, "-=0.15"); // Start before rcActions finishes, overlapping with last items
      
      // Animate card header (profile block) in first
      const cardRightHeader = elements.cardRight.querySelector('.card-header');
      if (cardRightHeader) {
        mainTimeline.to(cardRightHeader, {
          opacity: 1,
          y: 0,
          duration: 0.4,
          ease: "power1.out"
        }, '<');
      }
      
      // Type text word-by-word (1.6 seconds)
      const rightTextTimeline = typeText(elements.cardRightText, cardMessages.right, 1.6);
      mainTimeline.add(rightTextTimeline, "+=0.2");
      
      // Animate reaction bubbles one by one - start immediately after text finishes
      const rightBubbles = elements.cardRightReaction.querySelectorAll('.reaction-bubble');
      rightBubbles.forEach((bubble, i) => {
        mainTimeline.from(bubble, {
          opacity: 0,
          scale: 0,
          duration: 0.3,
          ease: "back.out(1.7)"
        }, `+=${i === 0 ? 0.05 : 0.1}`); // First emoji starts almost immediately after text, second shortly after
      });
      mainTimeline.to(elements.cardRightReaction, { opacity: 1, duration: 0.01 }, '<');

      // Phase 8: second card (left card - starts as first card's first emoji appears)
      mainTimeline.to(elements.cardLeft, {
        opacity: 1,
        scale: 1,
        y: 0,
        rotation: -4,
        duration: 0.7,
        ease: "back.out(1.2)",
        onComplete: () => elements.cardLeft.classList.add('shadow-final')
      }, "-=0.3"); // Start as first emoji appears (0.3s before first emoji finishes, creating overlap)
      
      // Animate card header (profile block) in first
      const cardHeader = elements.cardLeft.querySelector('.card-header');
      if (cardHeader) {
        mainTimeline.to(cardHeader, {
          opacity: 1,
          y: 0,
          duration: 0.4,
          ease: "power1.out"
        }, '<');
      }
      
      // Then type text word-by-word
      mainTimeline.add(typeText(elements.cardLeftText, cardMessages.left, 1.6), "+=0.2");
      
      // Animate reaction bubbles one by one - start immediately after text finishes
      const leftBubbles = elements.cardLeftReaction.querySelectorAll('.reaction-bubble');
      leftBubbles.forEach((bubble, i) => {
        mainTimeline.from(bubble, {
          opacity: 0,
          scale: 0,
          duration: 0.3,
          ease: "back.out(1.7)"
        }, `+=${i === 0 ? 0.05 : 0.1}`); // Start almost immediately after text finishes
      });
      mainTimeline.to(elements.cardLeftReaction, { opacity: 1, duration: 0.01 }, '<');

      // Phase 9: settle + gentle outro
      mainTimeline.to([elements.cardRight, elements.cardLeft], {
        opacity: 0,
        scale: 0.9,
        y: 80,
        rotation: 0,
        duration: 0.5,
        stagger: 0.2,
        ease: 'power1.inOut'
      }, "+=2.2");

      mainTimeline.to(elements.rootCauseView, {
        opacity: 0,
        duration: 0.4,
        ease: 'power1.inOut'
      }, "+=0.6");
    }

    // Start animation when page loads
    window.addEventListener('load', () => {
      try {
        setupVisibilityControls();
        runAnimation();
        updateMinHeight();
      } catch (error) {
        console.error('Animation setup error:', error);
        embedIsInView = true;
        runAnimation();
        updateMinHeight();
      }
    });

    window.addEventListener('resize', () => {
      updateMinHeight();
    });
  </script>
</body>
</html>
