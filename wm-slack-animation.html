 <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Slack Bot Animation - GSAP</title>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/TextPlugin.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
      background-color: #E7EDEF;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 40px 20px;
    }

    .container {
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
      position: relative;
      contain: layout style;
      overflow: visible; /* allow shadows to render fully */
    }

    /* Floating Cards */
    .floating-card {
      position: absolute;
      background: linear-gradient(to top, #ffffff 76.25%, #e2e2e2 96.814%);
      border-radius: 10.917px;
      /* Cheaper shadow while the card is moving */
      box-shadow: 0 10px 20px rgba(0,0,0,0.12);
      padding: 18.06px 22.575px;
      z-index: 50;
      opacity: 0;
      transform: translate3d(0, 100px, 0) scale(0.8);
      will-change: transform, opacity;
    }
    
    .floating-card::after {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(to right, transparent, rgba(255,255,255,0.9), transparent);
      z-index: 30;
      pointer-events: none;
      border-radius: 10.917px 10.917px 0 0;
    }

    /* Apply the heavier shadow only after the card settles */
    .floating-card.shadow-final {
      box-shadow: -13.646px 1.365px 27.293px 0px rgba(0,0,0,0.2);
    }

    .floating-card.right {
      right: 3%;
      bottom: 25%;
      width: 300px;
    }

    .floating-card.left {
      left: 3%;
      bottom: 15%;
      width: 300px;
    }

    .card-text {
      font-size: 16.141px;
      line-height: 24.832px;
      color: #1d1c1d;
      font-weight: 500;
      margin-bottom: 9.03px;
    }

    #card-right-text,
    #card-left-text {
      font-weight: 400;
    }

    .card-reaction {
      display: flex;
      gap: 9.03px;
      opacity: 0;
    }

    .reaction-bubble {
      background: #f2f2f2;
      border: 1.129px solid #e8e8e8;
      border-radius: 13.545px;
      padding: 4.776px 8.188px;
      display: flex;
      align-items: center;
      gap: 5.459px;
      font-size: 16.376px;
    }

    .reaction-bubble span {
      color: #1d1c1d;
    }

    .card-header {
      display: flex;
      align-items: center;
      gap: 10.917px;
      margin-bottom: 9.03px;
    }

    .card-avatar {
      width: 40.939px;
      height: 40.939px;
      border-radius: 8.188px;
      overflow: hidden;
    }

    .card-avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .card-name {
      font-size: 16.144px;
      font-weight: 700;
      color: #1d1c1d;
    }

    .card-time {
      font-size: 10.917px;
      color: #616061;
    }

    /* Main Window */
    .slack-window {
      width: 720px;
      margin: 0 auto;
      background: white;
      border-radius: 16px;
      border-top-left-radius: 16px;
      border-top-right-radius: 16px;
      border-bottom-right-radius: 16px;
      border-bottom-left-radius: 16px;
      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
      display: flex;
      overflow: hidden;
      position: relative;
      z-index: 10;
    }

    .slack-window::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 20%;
      background: linear-gradient(to bottom, #e2e2e2, transparent);
      z-index: 10;
      pointer-events: none;
    }

    .slack-window::after {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(to right, transparent, rgba(255,255,255,0.9), transparent);
      z-index: 30;
      pointer-events: none;
    }

    /* Stroke border trace effect */
    .border-trace-svg {
      position: absolute;
      inset: -1px;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 100;
      border-radius: 16px;
    }

    .border-trace-svg rect {
      stroke-dasharray: 80 320;
      stroke-dashoffset: 400;
      stroke-linecap: round;
      stroke-width: 1.5;
      animation: traceBorder 1.6s linear forwards,
                 traceFade 0.5s ease-in forwards 1.6s;
      filter: drop-shadow(0 0 3px rgba(245, 102, 48, 0.3));
      opacity: 1;
    }

    @keyframes traceBorder {
      to {
        stroke-dashoffset: -90;
      }
    }

    @keyframes traceFade {
      from { opacity: 1; }
      to { opacity: 0; }
    }

    /* Sidebar */
    .sidebar {
      width: 64px;
      background: #4A154B;
      padding: 12px 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
      flex-shrink: 0;
      position: relative;
      z-index: 20;
    }

    .sidebar-icon {
      width: 40px;
      height: 40px;
      border-radius: 8px;
      background: rgba(255,255,255,0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      color: rgba(255,255,255,0.7);
    }

    .sidebar-icon svg {
      width: 20px;
      height: 20px;
    }

    .slack-logo {
      width: 32px;
      height: 32px;
      margin-bottom: 8px;
    }

    /* Main Content */
    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-width: 0;
      position: relative;
      z-index: 20;
    }

    .header {
      background: transparent;
      border-bottom: 1px solid rgba(229, 231, 235, 0.5);
      padding: 8px 12px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .header-title {
      font-size: 14px;
      font-weight: 700;
      color: #111827;
    }

    .header-subtitle {
      font-size: 12px;
      font-weight: 600;
      color: #6B7280;
      margin-left: 8px;
    }

    .header-icons {
      display: flex;
      gap: 8px;
      color: #6B7280;
    }

    .header-icons svg {
      width: 16px;
      height: 16px;
    }

    .chat-content {
      padding: 16px;
      height: 480px;
      overflow: hidden;
      position: relative;
    }
    
    .root-cause-screen.active {
      display: block;
      height: 100%;
      overflow: visible;
    }

    /* Bot Header */
    .bot-header {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
    }

    .bot-avatar {
      width: 32px;
      height: 32px;
      border-radius: 6px;
      overflow: hidden;
      flex-shrink: 0;
      background: linear-gradient(135deg, #C5E3E9, #08363F);
      position: relative;
      animation: avatarGlow 3s ease-in-out infinite;
      will-change: box-shadow;
    }

    @keyframes avatarGlow {
      0%, 100% {
        box-shadow: 0 0 0 0 rgba(197, 227, 233, 0.4),
                    0 0 8px 2px rgba(197, 227, 233, 0.2);
      }
      50% {
        box-shadow: 0 0 0 4px rgba(197, 227, 233, 0.1),
                    0 0 16px 4px rgba(197, 227, 233, 0.3);
      }
    }

    .bot-info {
      flex: 1;
    }

    .bot-name {
      font-size: 14px;
      font-weight: 600;
      color: #111827;
      display: inline-block;
    }

    .bot-badge {
      font-size: 12px;
      background: #DBEAFE;
      color: #1E40AF;
      padding: 2px 6px;
      border-radius: 4px;
      margin-left: 8px;
    }

    .bot-time {
      font-size: 12px;
      color: #6B7280;
      margin-left: 8px;
    }

    .bot-status {
      font-size: 12px;
      color: #6B7280;
      margin-top: 2px;
      display: flex;
      align-items: center;
      gap: 6px;
      position: relative;
    }
    
    .bot-status #status-text {
      position: relative;
      background: linear-gradient(90deg, 
        #6B7280 0%, 
        #3B82F6 30%, 
        #9CA3AF 50%, 
        #3B82F6 70%, 
        #6B7280 100%
      );
      background-size: 300% 100%;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: shimmer 3s ease-in-out infinite;
    }
    
    @keyframes shimmer {
      0% { background-position: -200% 0; }
      50% { background-position: 0% 0; }
      100% { background-position: 200% 0; }
    }

    .loading-dots {
      display: inline-flex;
      gap: 2px;
    }

    .loading-dot {
      width: 4px;
      height: 4px;
      background: #6B7280;
      border-radius: 50%;
    }

    /* Dots animation (CSS-driven: cheaper than many GSAP repeat loops) */
    .dots-anim .loading-dot,
    .dots-anim .item-dot {
      opacity: 0.35;
      transform: scale(0.9);
      animation: dotPulse 1.2s ease-in-out infinite;
      will-change: transform, opacity;
    }

    .dots-anim .loading-dot:nth-child(1),
    .dots-anim .item-dot:nth-child(1) { animation-delay: 0s; }

    .dots-anim .loading-dot:nth-child(2),
    .dots-anim .item-dot:nth-child(2) { animation-delay: 0.15s; }

    .dots-anim .loading-dot:nth-child(3),
    .dots-anim .item-dot:nth-child(3) { animation-delay: 0.3s; }

    @keyframes dotPulse {
      0%, 100% { opacity: 0.35; transform: scale(0.9); }
      50%      { opacity: 1;    transform: scale(1.15); }
    }

    /* Items Container */
    .items-container {
      position: relative;
      height: 370px;
      background: white;
      border: 1px solid #F3F4F6;
      border-radius: 4px;
      overflow: hidden;
      contain: layout style paint;
      will-change: transform;
    }

    .items-container::after {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(
        90deg,
        transparent 0%,
        rgba(59, 130, 246, 0.05) 50%,
        transparent 100%
      );
      transform: translateX(-100%);
      animation: containerShimmer 4s ease-in-out infinite;
      pointer-events: none;
      z-index: 1;
      will-change: transform;
    }

    @keyframes containerShimmer {
      0% { transform: translateX(-100%); }
      50%, 100% { transform: translateX(100%); }
    }

    .items-fade-top {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 48px;
      background: transparent;
      z-index: 20;
      pointer-events: none;
      display: none;
    }

    .items-fade-bottom {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 48px;
      background: linear-gradient(to top, white, transparent);
      z-index: 20;
      pointer-events: none;
    }

    .items-list {
      position: absolute;
      inset: 0;
      padding: 8px 12px;
    }

    .check-item {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 6px 8px;
      border-radius: 4px;
      margin-bottom: 4px;
      transition: background-color 0.3s;
      opacity: 0;
      transform: translateY(20px);
      will-change: transform, opacity;
    }

    .check-item.waiting { 
      background: #F3F4F6; 
      border: 1px solid #E5E7EB;
    }
    .check-item.fetching { 
      background: #EFF6FF; 
      border: 1px solid #DBEAFE;
      --pulse-color: rgba(59, 130, 246, 0.65);
      --pulse-shadow: rgba(59, 130, 246, 0.25);
    }
    .check-item.analyzing { 
      background: #F5F3FF; 
      border: 1px solid #EDE9FE;
      --pulse-color: rgba(139, 92, 246, 0.65);
      --pulse-shadow: rgba(139, 92, 246, 0.25);
    }
    .check-item.complete { 
      background: #F0FDF4; 
      border: 1px solid #DCFCE7;
      --pulse-color: rgba(34, 197, 94, 0.65);
      --pulse-shadow: rgba(34, 197, 94, 0.25);
    }

    @keyframes itemActivePulse {
      0%, 100% {
        border-color: var(--pulse-color, rgba(59, 130, 246, 0.65));
        box-shadow: 0 0 0 0 var(--pulse-shadow, rgba(59, 130, 246, 0.25));
      }
      50% {
        border-color: var(--pulse-color, rgba(59, 130, 246, 0.65));
        box-shadow: 0 0 8px 0 var(--pulse-shadow, rgba(59, 130, 246, 0.25));
      }
    }

    .item-label {
      font-weight: 600;
      color: #111827;
      font-size: 11px;
      flex-shrink: 0;
    }

    .check-item.complete .item-label {
      font-size: 13px;
    }

    .item-content {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      min-width: 0;
    }

    .item-status {
      font-size: 11px;
      color: #6B7280;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      flex: 1;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .check-item.complete .item-status {
      font-size: 13px;
      color: #111827;
    }

    .item-star {
      opacity: 0;
      transform: scale(0) rotate(-180deg);
      font-size: 16px;
      display: inline-block;
    }

    .item-button {
      padding: 6px 12px;
      font-size: 12px;
      border: 1px solid #D1D5DB;
      border-radius: 4px;
      background: white;
      font-weight: 600;
      cursor: pointer;
      flex-shrink: 0;
      opacity: 0;
      transform: scale(0.8);
      color: #111827;
    }

    .item-button:hover {
      background: #F9FAFB;
    }

    .item-dots {
      display: flex;
      gap: 3px;
      flex-shrink: 0;
      align-items: center;
    }

    .item-dot {
      width: 4px;
      height: 4px;
      background: #9CA3AF;
      border-radius: 50%;
      animation: dotPulse 1.4s ease-in-out infinite;
    }
    
    .item-dot:nth-child(1) { animation-delay: 0s; }
    .item-dot:nth-child(2) { animation-delay: 0.2s; }
    .item-dot:nth-child(3) { animation-delay: 0.4s; }

    /* Progress Bar */
    .progress-container {
      margin-top: 8px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: 12px;
      color: #6B7280;
    }

    .progress-bar {
      width: 128px;
      height: 4px;
      background: #E5E7EB;
      border-radius: 9999px;
      overflow: hidden;
      margin-left: auto;
      position: relative;
    }

    .progress-fill {
      height: 100%;
      background: #3B82F6;
      width: 100%;
      transform: scaleX(0);
      transform-origin: left;
      transition: transform 0.3s;
      will-change: transform;
      position: absolute;
      top: 0;
      left: 0;
    }

    /* Root Cause Screen */
    .root-cause-screen {
      opacity: 0;
      display: none;
    }

    .root-cause-screen.active {
      display: block;
      min-height: 100%;
      padding-bottom: 16px;
    }

    .root-cause-screen .bot-header {
      margin-bottom: 20px;
    }

    .rc-alert {
      font-size: 12px;
      color: #4B5563;
      margin-bottom: 8px;
    }

    .rc-alert-id {
      color: #374151;
    }

    .rc-box {
      background: #F9FAFB;
      border-left: 4px solid #9CA3AF;
      padding: 10px;
      border-radius: 4px;
      margin-bottom: 8px;
    }

    .rc-title {
      font-size: 14px;
      font-weight: 600;
      color: #111827;
      margin-bottom: 6px;
    }

    .rc-text {
      font-size: 12px;
      color: #374151;
      line-height: 1.5;
    }

    .rc-text code {
      background: #E5E7EB;
      padding: 2px 4px;
      border-radius: 2px;
      font-size: 12px;
    }

    .rc-button {
      background: #0D9488;
      color: white;
      padding: 6px 12px;
      border-radius: 4px;
      border: none;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      margin-bottom: 8px;
    }

    .rc-button:hover {
      background: #0F766E;
    }

    .rc-items {
      margin-bottom: 8px;
    }

    .rc-item {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 12px;
      margin-bottom: 4px;
    }

    .rc-item-label {
      font-weight: 600;
      color: #111827;
    }

    .rc-item-content {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .rc-item-text {
      color: #111827;
      flex: 1;
    }
    
    .rc-item-text .star-emoji {
      font-size: 16px;
      display: inline-block;
      margin-left: 4px;
    }

    .rc-actions {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
    }

    .rc-action-btn {
      padding: 6px 12px;
      border: 1px solid #D1D5DB;
      border-radius: 4px;
      background: white;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      color: #111827;
    }

    .rc-action-btn:hover {
      background: #F9FAFB;
    }

    .rc-feedback {
      display: flex;
      gap: 8px;
      margin-bottom: 0;
    }

    .rc-feedback-btn {
      padding: 4px 8px;
      border: 1px solid #D1D5DB;
      border-radius: 4px;
      background: white;
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 4px;
      color: #111827;
    }

    .rc-feedback-btn:hover {
      background: #F9FAFB;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Right Floating Card -->
    <div class="floating-card right" id="card-right">
      <div class="card-header">
        <div class="card-avatar">
          <img src="https://images.unsplash.com/photo-1472099645785-5658abf4ff4e?w=100&h=100&fit=crop" alt="Avatar">
        </div>
        <div>
          <div class="card-name">marcus</div>
          <div class="card-time">Aug 25th at 9:45 AM</div>
        </div>
      </div>
      <div class="card-text">
        <span id="card-right-text">Wow! It's very impressive that it got it right that time</span>
      </div>
      <div class="card-reaction" id="card-right-reaction">
        <div class="reaction-bubble">
          <span>üëç</span>
          <span style="font-weight: 600; font-size: 10.917px;">2</span>
        </div>
      </div>
    </div>

    <!-- Left Floating Card -->
    <div class="floating-card left" id="card-left">
      <div class="card-header">
        <div class="card-avatar">
          <img src="https://images.unsplash.com/photo-1494790108377-be9c29b29330?w=100&h=100&fit=crop" alt="Avatar">
        </div>
        <div>
          <div class="card-name">sarah</div>
          <div class="card-time">Aug 25th at 9:42 AM</div>
        </div>
      </div>
      <div class="card-text">
        <span id="card-left-text">Wow, there was barely any evidence to work with.</span>
      </div>
      <div class="card-reaction" id="card-left-reaction">
        <div class="reaction-bubble">
          <span>üòÆ</span>
          <span style="font-weight: 600; font-size: 10.917px;">1</span>
        </div>
        <div class="reaction-bubble">
          <span>üéØ</span>
        </div>
      </div>
    </div>

    <!-- Main Slack Window -->
    <div class="slack-window">
      <!-- Animated stroke border trace -->
      <svg class="border-trace-svg" viewBox="0 0 100 100" preserveAspectRatio="none" fill="none" xmlns="http://www.w3.org/2000/svg">
        <rect x="2" y="2" width="96" height="96" rx="3" stroke="url(#borderGradient)" stroke-width="2" pathLength="100"/>
        <defs>
          <linearGradient id="borderGradient" x1="0%" y1="0%" x2="100%" y2="0%">
            <stop offset="0%" style="stop-color:rgba(245, 102, 48, 1);stop-opacity:1" />
            <stop offset="60%" style="stop-color:rgba(245, 102, 48, 0.35);stop-opacity:0.35" />
            <stop offset="100%" style="stop-color:rgba(245, 102, 48, 0);stop-opacity:0" />
          </linearGradient>
        </defs>
      </svg>
      <!-- Sidebar -->
      <div class="sidebar">
        <div class="slack-logo">
          <svg viewBox="0 0 50 50" fill="none">
            <path d="M18.1892 10.3714C15.3213 10.3714 13.0035 8.05352 13.0035 5.18568C13.0035 2.31784 15.3213 0 18.1892 0C21.057 0 23.3748 2.31784 23.3748 5.18568V10.3714H18.1892ZM18.1892 13.0035C21.057 13.0035 23.3748 15.3213 23.3748 18.1892C23.3748 21.057 21.057 23.3748 18.1892 23.3748H5.18568C2.31784 23.3748 0 21.057 0 18.1892C0 15.3213 2.31784 13.0035 5.18568 13.0035H18.1892Z" fill="#36C5F0"/>
            <path d="M38.9712 18.1892C38.9712 15.3213 41.289 13.0035 44.1569 13.0035C47.0247 13.0035 49.3425 15.3213 49.3425 18.1892C49.3425 21.057 47.0247 23.3748 44.1569 23.3748H38.9712V18.1892ZM36.3783 18.1892C36.3783 21.057 34.0605 23.3748 31.1927 23.3748C28.3248 23.3748 26.007 21.057 26.007 18.1892V5.18568C26.007 2.31784 28.3248 2.85901e-06 31.1927 2.85901e-06C34.0605 2.85901e-06 36.3783 2.31784 36.3783 5.18568V18.1892Z" fill="#2EB67D"/>
            <path d="M10.4107 31.1926C10.4107 34.0604 8.09289 36.3783 5.22505 36.3783C2.35721 36.3783 0.0393729 34.0604 0.0393729 31.1926C0.0393729 28.3247 2.35721 26.0069 5.22505 26.0069H10.4107V31.1926ZM13.0036 31.1926C13.0036 28.3247 15.3214 26.0069 18.1893 26.0069C21.0571 26.0069 23.3749 28.3247 23.3749 31.1926V44.1568C23.3749 47.0246 21.0571 49.3425 18.1893 49.3425C15.3214 49.3425 13.0036 47.0246 13.0036 44.1568V31.1926Z" fill="#E01E5A"/>
            <path d="M31.1927 38.9711C34.0605 38.9711 36.3783 41.289 36.3783 44.1568C36.3783 47.0246 34.0605 49.3425 31.1927 49.3425C28.3248 49.3425 26.007 47.0246 26.007 44.1568V38.9711H31.1927ZM31.1927 36.3783C28.3248 36.3783 26.007 34.0604 26.007 31.1926C26.007 28.3247 28.3248 26.0069 31.1927 26.0069H44.1961C47.064 26.0069 49.3818 28.3247 49.3818 31.1926C49.3818 34.0604 47.064 36.3783 44.1961 36.3783H31.1927Z" fill="#ECB22E"/>
          </svg>
        </div>
        <div class="sidebar-icon">
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 20l4-16m2 16l4-16M6 9h14M4 15h14"></path></svg>
        </div>
        <div class="sidebar-icon">
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"></path></svg>
        </div>
        <div class="sidebar-icon">
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197M13 7a4 4 0 11-8 0 4 4 0 018 0z"></path></svg>
        </div>
        <div class="sidebar-icon">
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 5a2 2 0 012-2h10a2 2 0 012 2v16l-7-3.5L5 21V5z"></path></svg>
        </div>
      </div>

      <!-- Main Content -->
      <div class="main-content">
        <!-- Header -->
        <div class="header">
          <div>
            <span class="header-title">Thread</span>
            <span class="header-subtitle">Wild Moose (Dev)</span>
          </div>
          <div class="header-icons">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"></path></svg>
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9"></path></svg>
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
          </div>
        </div>

        <!-- Chat Content -->
        <div class="chat-content">
          <!-- Processing View -->
          <div id="processing-view">
            <div class="bot-header">
              <div class="bot-avatar">
                <img src="wildmoose-avatar.png" alt="Wild Moose" style="width: 100%; height: 100%; object-fit: cover; border-radius: 6px;">
              </div>
              <div class="bot-info">
                <div>
                  <span class="bot-name">Wild Moose (Dev)</span>
                  <span class="bot-badge">APP</span>
                  <span class="bot-time">Just now</span>
                </div>
                <div class="bot-status">
                  <div class="loading-dots" id="status-dots">
                    <div class="loading-dot"></div>
                    <div class="loading-dot"></div>
                    <div class="loading-dot"></div>
                  </div>
                  <span id="status-text">Collecting evidence from data sources</span>
                </div>
              </div>
            </div>

            <div class="items-container">
              <div class="items-fade-top"></div>
              <div class="items-fade-bottom"></div>
              <div class="items-list" id="items-list"></div>
            </div>

            <div class="progress-container">
              <span>Processing: <span id="progress-count">0</span> / 18</span>
              <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
              </div>
            </div>
          </div>

          <!-- Root Cause View -->
          <div id="root-cause-view" class="root-cause-screen">
            <div class="bot-header">
              <div class="bot-avatar">
                <img src="wildmoose-avatar.png" alt="Wild Moose" style="width: 100%; height: 100%; object-fit: cover; border-radius: 6px;">
              </div>
              <div class="bot-info">
                <div>
                  <span class="bot-name">Wild Moose (Dev)</span>
                  <span class="bot-badge">APP</span>
                  <span class="bot-time">1 minute ago</span>
                </div>
                <div class="bot-status">
                  <span>Alert Enrichment Ready</span>
                </div>
              </div>
            </div>

            <div class="rc-alert">
              For alert: <span class="rc-alert-id">#66515: [Grafana]: SLO response time PlatformMetadataService getProviderDataById com.wixpress.payment.payment-metadata-web</span>
            </div>

            <div class="rc-box">
              <div class="rc-title">Root Cause:</div>
              <div class="rc-text">
                The latency spike for <code>getProviderData</code> in <code>payment-web</code> is isolated to <code>us-west-2</code> and driven by population service timeouts which cascade to higher response times. The population service experienced a 340% increase in <code>DeadlineExceededException</code> errors during HPA pod warmup, causing cascading failures to <code>payment-web</code>.
              </div>
            </div>

            <button class="rc-button">Scale payment-web</button>

            <div class="rc-items" id="rc-items"></div>

            <div class="rc-actions">
              <button class="rc-action-btn">Run Again</button>
              <button class="rc-action-btn">Re-analyze</button>
            </div>

            <div class="rc-feedback">
              <button class="rc-feedback-btn">üëç Correct</button>
              <button class="rc-feedback-btn">ü§ö Halfway</button>
              <button class="rc-feedback-btn">üëé Wrong</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Ensure the text plugin is available for typewriter effects
    if (window.gsap && window.TextPlugin) {
      gsap.registerPlugin(TextPlugin);
    }
    gsap.registerPlugin(TextPlugin);

    const TOTAL_ITEMS = 18;
    const itemLabels = [
      'War room threads',
      'Lost quorum (specific/all DCs?)',
      'Failing health checks',
      'DC switch',
      'Top exception',
      'Errors Sample request ID',
      'Source of error',
      'Cascading errors sequence',
      'Stack trace analysis',
      'Caller Distribution',
      'p50 vs p95, WEB vs KAFKA vs SERVER',
      "Exception's frequency anomalies",
      'Traffic (RPM) increase',
      'DB query RPM anomalies',
      'Misbehaving pod anomalies',
      'Recent deployments',
      'Config changes',
      'Memory usage patterns',
    ];

    const itemResults = [
      'None',
      'No.',
      'No failing health checks detected in the last 30 minutes.',
      'No DC switch detected in the 30 minutes before the alert.',
      'DeadlineExceededException at getProviderDataById',
      'req_abc123xyz789',
      'Population service timeout cascading to payment-web',
      'Payment-web ‚Üí Population-service ‚Üí Database timeout',
      'Exception originates from population service HPA pod warmup',
      'Evenly distributed across all callers',
      'p95 spike isolated to SERVER calls in us-west-2',
      'Frequency increased 340% in last 15 minutes',
      'RPM increased 25% coinciding with new pod scaling',
      'Query timeout spike for getUserPopulation in us-west-2',
      'Uneven heap memory usage detected in newly scaled pods',
      'No deployments in the last 2 hours',
      'No configuration changes detected',
      'Memory pressure on 3 out of 8 pods in us-west-2',
    ];

    // Add more random stars - original 5 plus 3 more random ones
    const starredItems = [1, 4, 6, 11, 14, 2, 9, 16];

    const cardMessages = {
      right: "Wow! It's very impressive that it got it right that time",
      left: "Wow, there was barely any evidence to work with."
    };
    
    // Data sources for fetching phase
    const dataSources = ['logs', 'metrics', 'traces'];
    const itemDataSources = {}; // Store which source each item is fetching from

    let mainTimeline;
    let processedCount = 0;
    let loadingDotsAnimation;
    let itemDotsAnimations = [];
    const itemElements = [];
    
    // Cache DOM elements for performance
    const elements = {
      itemsList: null,
      processingView: null,
      rootCauseView: null,
      progressCount: null,
      progressFill: null,
      statusText: null,
      cardRight: null,
      cardLeft: null,
      cardRightText: null,
      cardLeftText: null,
      cardRightReaction: null,
      cardLeftReaction: null,
      rcItems: null
    };

    function typeText(element, text, duration = 2) {
      const tl = gsap.timeline();
      tl.to(element, {
        duration: duration,
        text: text,
        ease: "none"
      });
      return tl;
    }

    function animateLoadingDots() {
      const statusDots = document.getElementById('status-dots');
      if (statusDots) statusDots.classList.add('dots-anim');
    }

    function animateItemDots(itemEl) {
      const dotsContainer = itemEl?.querySelector?.('.item-dots');
      if (dotsContainer) dotsContainer.classList.add('dots-anim');
    }
    
    function cleanupAnimations() {
      itemDotsAnimations = [];
      loadingDotsAnimation = null;

      if (mainTimeline) {
        mainTimeline.kill();
        mainTimeline = null;
      }
    }

    function setDotsActive(active) {
      const statusDots = document.getElementById('status-dots');
      const processingView = document.getElementById('processing-view');
      const processingVisible = processingView && window.getComputedStyle(processingView).display !== 'none' && window.getComputedStyle(processingView).opacity !== '0';
      if (statusDots) {
        if (active && processingVisible) {
          statusDots.classList.add('dots-anim');
        } else {
          statusDots.classList.remove('dots-anim');
        }
      }

      const itemDots = document.querySelectorAll('.item-dots');
      itemDots.forEach((el) => {
        if (!active) {
          el.classList.remove('dots-anim');
          return;
        }
        const style = window.getComputedStyle(el);
        if (style.display !== 'none' && style.visibility !== 'hidden' && style.opacity !== '0') {
          el.classList.add('dots-anim');
        }
      });
    }

    let visibilityControlsInitialized = false;
    let embedIsInView = true;

    function checkInitialVisibility() {
      // Synchronous check: is the embed actually visible on page load?
      const target = document.querySelector('.container') || document.querySelector('.slack-window');
      if (!target) return true; // Default to visible if we can't find it
      
      const rect = target.getBoundingClientRect();
      const viewportHeight = window.innerHeight || document.documentElement.clientHeight;
      // Consider visible if any part is in the viewport (or just below it, since it's "just after fold")
      return rect.top < viewportHeight + 200; // 200px buffer for "just after fold"
    }

    function setupVisibilityControls() {
      if (visibilityControlsInitialized) return;
      visibilityControlsInitialized = true;

      // Observe the whole embed; since it's below the fold, pause when offscreen.
      const target = document.querySelector('.container') || document.querySelector('.slack-window');
      if (!target) {
        // If we can't find the target, just set embedIsInView to true and continue
        embedIsInView = true;
        return;
      }

      const pauseAll = () => {
        if (mainTimeline) {
          mainTimeline.pause();
        }
        setDotsActive(false);
      };

      const resumeAll = () => {
        if (document.hidden) return;
        if (!embedIsInView) return;
        if (mainTimeline) {
          mainTimeline.resume();
        }
        // Only re-enable dots for currently-visible dot containers
        setDotsActive(true);
      };

      const observer = new IntersectionObserver(
        (entries) => {
          embedIsInView = !!entries[0]?.isIntersecting;
          if (!embedIsInView) {
            pauseAll();
          } else {
            resumeAll();
          }
        },
        { threshold: 0.1, rootMargin: '100px' } // More lenient: start animating when close to viewport
      );

      observer.observe(target);

      // Set initial state based on synchronous check
      embedIsInView = checkInitialVisibility();

      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          pauseAll();
        } else {
          resumeAll();
        }
      });
    }

    function createCheckItem(index) {
      const item = document.createElement('div');
      item.className = 'check-item waiting';
      item.id = `item-${index}`;
      item.innerHTML = `
        <span class="item-label">${itemLabels[index]}:</span>
        <div class="item-content">
          <div class="item-status">
            <span class="status-text">Waiting for dependencies</span>
            <div class="item-dots">
              <div class="item-dot"></div>
              <div class="item-dot"></div>
              <div class="item-dot"></div>
            </div>
            <span class="item-star">${starredItems.includes(index) ? '‚≠ê' : ''}</span>
          </div>
          <button class="item-button">See more</button>
          <svg class="item-more" width="12" height="12" fill="none" stroke="#9CA3AF" viewBox="0 0 24 24">
            <circle cx="12" cy="12" r="1"></circle>
            <circle cx="19" cy="12" r="1"></circle>
            <circle cx="5" cy="12" r="1"></circle>
          </svg>
        </div>
      `;
      return item;
    }

    function cacheElements() {
      if (elements.itemsList) return;
      elements.itemsList = document.getElementById('items-list');
      elements.processingView = document.getElementById('processing-view');
      elements.rootCauseView = document.getElementById('root-cause-view');
      elements.progressCount = document.getElementById('progress-count');
      elements.progressFill = document.getElementById('progress-fill');
      elements.statusText = document.getElementById('status-text');
      elements.cardRight = document.getElementById('card-right');
      elements.cardLeft = document.getElementById('card-left');
      elements.cardRightText = document.getElementById('card-right-text');
      elements.cardLeftText = document.getElementById('card-left-text');
      elements.cardRightReaction = document.getElementById('card-right-reaction');
      elements.cardLeftReaction = document.getElementById('card-left-reaction');
      elements.rcItems = document.getElementById('rc-items');
    }

    function measureCardHeight(cardEl, finalText) {
      if (!cardEl) return 0;
      const clone = cardEl.cloneNode(true);
      clone.style.position = 'absolute';
      clone.style.left = '-9999px';
      clone.style.top = '-9999px';
      clone.style.opacity = '0';
      clone.style.transform = 'none';
      clone.style.minHeight = 'auto';
      const textSpan = clone.querySelector('.card-text span');
      if (textSpan) textSpan.textContent = finalText;
      document.body.appendChild(clone);
      const height = clone.offsetHeight;
      document.body.removeChild(clone);
      return height;
    }

    // Ensure cards reserve their final height so the type animation doesn't grow them
    function setCardBaseHeights() {
      if (!elements.cardRight || !elements.cardLeft) return;
      
      // Cards have text pre-filled, so we can measure their natural height
      const rightHeight = elements.cardRight.offsetHeight;
      const leftHeight = elements.cardLeft.offsetHeight;
      
      // Lock the height so typing doesn't cause growth
      if (rightHeight) {
        elements.cardRight.style.height = `${rightHeight}px`;
      }
      if (leftHeight) {
        elements.cardLeft.style.height = `${leftHeight}px`;
      }
    }

    function buildStaticItems() {
      if (!elements.itemsList || itemElements.length) return;
      const fragment = document.createDocumentFragment();
      for (let i = 0; i < TOTAL_ITEMS; i++) {
        const item = createCheckItem(i);
        fragment.appendChild(item);
        itemElements.push({
          index: i,
          root: item,
          status: item.querySelector('.status-text'),
          dots: item.querySelector('.item-dots'),
          star: item.querySelector('.item-star'),
          button: item.querySelector('.item-button'),
          more: item.querySelector('.item-more'),
        });
      }
      elements.itemsList.appendChild(fragment);
    }

    function buildRootCauseStatic() {
      if (!elements.rcItems || elements.rcItems.childElementCount) return;
      const fragment = document.createDocumentFragment();
      for (let i = 0; i < 4; i++) {
        const item = document.createElement('div');
        item.className = 'rc-item';
        item.innerHTML = `
          <span class="rc-item-label">${itemLabels[i]}:</span>
          <div class="rc-item-content">
            <span class="rc-item-text">${itemResults[i]}${starredItems.includes(i) ? '<span class="star-emoji">‚≠ê</span>' : ''}</span>
            <button class="item-button">See more</button>
          </div>
        `;
        fragment.appendChild(item);
      }
      elements.rcItems.appendChild(fragment);
    }

    function resetItemState(item, phase = 'waiting') {
      item.root.className = `check-item ${phase}`;
      // clear any lingering one-shot pulse
      item.root.style.animation = 'none';

      if (item.status) {
        // Strong status change: old scales up and fades out, new scales down and fades in
        const oldText = item.status.textContent;
        let newText = '';
        if (phase === 'waiting') newText = 'Waiting for dependencies';
        else if (phase === 'fetching') {
          // Assign a random data source for this item if not already assigned
          if (!itemDataSources[item.index]) {
            itemDataSources[item.index] = dataSources[Math.floor(Math.random() * dataSources.length)];
          }
          newText = `Fetching ${itemDataSources[item.index]}`;
        }
        else if (phase === 'analyzing') newText = 'Analyzing result';
        else if (phase === 'complete') newText = itemResults[item.index];
        
        if (oldText !== newText && newText) {
          // Old status: scale up and fade out
          gsap.to(item.status, {
            scale: 1.3,
            opacity: 0,
            duration: 0.2,
            ease: 'power2.out',
            force3D: true,
            onComplete: () => {
              // Change text and set new status to start scaled down and invisible
              item.status.textContent = newText;
              gsap.set(item.status, { scale: 0.7, opacity: 0, force3D: true });
              // New status: scale down to normal and fade in
              gsap.to(item.status, {
                scale: 1,
                opacity: 1,
                duration: 0.25,
                ease: 'back.out(1.4)',
                force3D: true
              });
            }
          });
        } else {
          item.status.textContent = newText;
        }
      }

      if (item.dots) {
        item.dots.style.display = phase === 'complete' ? 'none' : 'flex';
        if (phase !== 'complete') animateItemDots(item.root);
      }

      if (item.button) {
        if (phase === 'complete') {
          gsap.to(item.button, {
            opacity: 1,
            scale: 1,
            duration: 0.2,
            ease: 'back.out(1.2)',
            force3D: true
          });
        } else {
          gsap.set(item.button, { opacity: 0, scale: 0.85, force3D: true });
        }
      }

      if (item.star) {
        if (phase === 'complete' && starredItems.includes(item.index)) {
          gsap.to(item.star, {
            opacity: 1,
            scale: 1,
            rotation: 0,
            duration: 0.25,
            ease: 'back.out(1.5)',
            force3D: true
          });
        } else {
          gsap.set(item.star, { opacity: 0, scale: 0, rotation: 0, force3D: true });
        }
      }

      if (item.more) {
        item.more.style.display = phase === 'complete' ? 'none' : 'inline';
      }
    }

    function resetAllState() {
      processedCount = 0;
      
      // Clear data source assignments for fresh randomization
      for (let key in itemDataSources) {
        delete itemDataSources[key];
      }

      // Restart border trace animation on sequence restart
      const borderRect = document.querySelector('.border-trace-svg rect');
      if (borderRect) {
        borderRect.style.animation = 'none';
        // force reflow to restart animation
        void borderRect.offsetWidth;
        borderRect.style.animation = 'traceBorder 1.6s ease-out forwards, traceFade 0.5s ease-in forwards 1.6s';
      }

      elements.processingView.style.display = 'block';
      gsap.set(elements.processingView, { opacity: 1, force3D: true });
      
      // Ensure bot header in processing view stays visible (persists across states)
      const processingBotHeader = elements.processingView?.querySelector('.bot-header');
      if (processingBotHeader) {
        gsap.set(processingBotHeader, { opacity: 1, y: 0, force3D: true });
      }
      
      // Restore progress container visibility
      const progressContainer = elements.processingView.querySelector('.progress-container');
      if (progressContainer) {
        progressContainer.style.display = 'flex';
      }
      
      elements.rootCauseView.classList.remove('active');
      elements.rootCauseView.style.display = 'none';
      gsap.set(elements.rootCauseView, { opacity: 0, force3D: true });
      
      // Ensure bot header in root cause view stays visible (persists across states)
      const rcBotHeader = elements.rootCauseView?.querySelector('.bot-header');
      if (rcBotHeader) {
        gsap.set(rcBotHeader, { opacity: 1, y: 0, force3D: true });
      }
      
      // Reset other root cause content children opacity
      if (elements.rootCauseView) {
        const rcAlert = elements.rootCauseView.querySelector('.rc-alert');
        const rcBox = elements.rootCauseView.querySelector('.rc-box');
        const rcButton = elements.rootCauseView.querySelector('.rc-button');
        const rcItems = elements.rootCauseView.querySelector('.rc-items');
        const rcActions = elements.rootCauseView.querySelector('.rc-actions');
        const rcFeedback = elements.rootCauseView.querySelector('.rc-feedback');
        
        // Set content to invisible (rcItems container stays visible, children animate)
        [rcAlert, rcBox, rcButton, rcActions, rcFeedback].forEach(el => {
          if (el) gsap.set(el, { opacity: 0, y: 8, force3D: true });
        });
        // rcItems container visible, but its children start invisible
        if (rcItems) {
          gsap.set(rcItems, { opacity: 1, y: 0, force3D: true });
          const rcItemElements = rcItems.querySelectorAll('.rc-item');
          rcItemElements.forEach(item => {
            gsap.set(item, { opacity: 0, y: 8, force3D: true });
          });
        }
      }

      elements.progressCount.textContent = '0';
      gsap.set(elements.progressFill, { scaleX: 0, force3D: true });

      elements.statusText.textContent = 'Collecting evidence from data sources';

      if (elements.cardRight) {
        elements.cardRight.classList.remove('shadow-final');
        gsap.set(elements.cardRight, { opacity: 0, scale: 0.9, y: 80, rotation: 0, force3D: true });
        if (elements.cardRightText) {
          elements.cardRightText.textContent = '';
          gsap.set(elements.cardRightText, { opacity: 1 });
        }
        // Hide card header initially
        const cardRightHeader = elements.cardRight.querySelector('.card-header');
        if (cardRightHeader) {
          gsap.set(cardRightHeader, { opacity: 0, y: -10 });
        }
      }
      if (elements.cardLeft) {
        elements.cardLeft.classList.remove('shadow-final');
        gsap.set(elements.cardLeft, { opacity: 0, scale: 0.9, y: 80, rotation: 0, force3D: true });
        if (elements.cardLeftText) {
          elements.cardLeftText.textContent = '';
          gsap.set(elements.cardLeftText, { opacity: 1 });
        }
        // Hide card header initially
        const cardHeader = elements.cardLeft.querySelector('.card-header');
        if (cardHeader) {
          gsap.set(cardHeader, { opacity: 0, y: -10 });
        }
      }
      if (elements.cardRightReaction) gsap.set(elements.cardRightReaction, { opacity: 0 });
      if (elements.cardLeftReaction) gsap.set(elements.cardLeftReaction, { opacity: 0 });

      itemElements.forEach((item) => {
        gsap.set(item.root, { opacity: 0, y: 20, scale: 1.15, force3D: true });
        if (item.status) {
          gsap.set(item.status, { scale: 1, opacity: 1, force3D: true });
        }
        resetItemState(item, 'waiting');
      });
    }

    function runAnimation() {
      cleanupAnimations();
      cacheElements();
      buildStaticItems();
      buildRootCauseStatic();
      setCardBaseHeights();
      resetAllState();
      animateLoadingDots();
      
      // Ensure dots are active at start
      setDotsActive(true);

      mainTimeline = gsap.timeline({
        defaults: { force3D: true },
        repeat: -1,
        repeatDelay: 0.5,
        onRepeat: () => {
          resetAllState();
          animateLoadingDots();
          setDotsActive(true);
        }
      });

      if (document.hidden || !embedIsInView) {
        mainTimeline.pause(0);
        setDotsActive(false);
      }

      // Phase 1: reveal items with stagger and scale-down effect
      itemElements.forEach((item, i) => {
        gsap.set(item.root, { scale: 1.15, force3D: true });
      });
      mainTimeline.to(itemElements.map((i) => i.root), {
        opacity: 1,
        y: 0,
        scale: 1,
        duration: 0.3,
        stagger: 0.1,
        ease: 'back.out(1.1)',
      }, 0);

      // Helper function to shuffle array (Fisher-Yates)
      function shuffleArray(array) {
        const shuffled = [...array];
        for (let i = shuffled.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        return shuffled;
      }

      // Phase 2: switch to fetching with randomized order
      const fetchingOrder = shuffleArray(itemElements.map((_, i) => i));
      fetchingOrder.forEach((itemIndex, orderIndex) => {
        const delay = orderIndex === 0 ? 0.35 : 0.08 + Math.random() * 0.15;
        mainTimeline.call(() => {
          resetItemState(itemElements[itemIndex], 'fetching');
          // one-shot pulse when entering fetching
          itemElements[itemIndex].root.style.animation = 'itemActivePulse 1s ease-out 1 forwards';
        }, null, `+=${delay}`);
      });

      // Phase 3: switch to analyzing with randomized order
      mainTimeline.call(() => {
        elements.statusText.textContent = 'Analyzing data from enrichment sources';
      }, null, '+=0.4');

      const analyzingOrder = shuffleArray(itemElements.map((_, i) => i));
      analyzingOrder.forEach((itemIndex, orderIndex) => {
        const delay = orderIndex === 0 ? 0.2 : 0.06 + Math.random() * 0.12;
        mainTimeline.call(() => {
          resetItemState(itemElements[itemIndex], 'analyzing');
          // one-shot pulse when entering analyzing
          itemElements[itemIndex].root.style.animation = 'itemActivePulse 1s ease-out 1 forwards';
        }, null, `+=${delay}`);
      });

      // Phase 4: complete items + progress with randomized order
      mainTimeline.call(() => {
        elements.statusText.textContent = 'Alert Enrichment Ready';
      }, null, '+=0.4');

      const completeOrder = shuffleArray(itemElements.map((_, i) => i));
      completeOrder.forEach((itemIndex, orderIndex) => {
        const delay = orderIndex === 0 ? 0.25 : 0.1 + Math.random() * 0.15;
        mainTimeline.call(() => {
          resetItemState(itemElements[itemIndex], 'complete');
          processedCount++;
          const progress = processedCount / TOTAL_ITEMS;
          elements.progressCount.textContent = processedCount;
          gsap.set(elements.progressFill, { scaleX: progress, force3D: true });
        }, null, `+=${delay}`);
      });

      // Phase 5: show root cause screen
      // Query elements before transition (they exist in DOM, just hidden)
      const rcBotHeader = elements.rootCauseView.querySelector('.bot-header');
      const rcAlert = elements.rootCauseView.querySelector('.rc-alert');
      const rcBox = elements.rootCauseView.querySelector('.rc-box');
      const rcButton = elements.rootCauseView.querySelector('.rc-button');
      const rcItems = elements.rootCauseView.querySelector('.rc-items');
      const rcActions = elements.rootCauseView.querySelector('.rc-actions');
      const rcFeedback = elements.rootCauseView.querySelector('.rc-feedback');
      
      mainTimeline.to(elements.processingView, {
        opacity: 0,
        duration: 0.45,
        ease: 'power1.out',
        onComplete: () => {
          setDotsActive(false);
          elements.processingView.style.display = 'none';
          // Ensure progress bar is completely hidden
          const progressContainer = elements.processingView.querySelector('.progress-container');
          if (progressContainer) {
            progressContainer.style.display = 'none';
          }
          
          elements.rootCauseView.classList.add('active');
          elements.rootCauseView.style.display = 'block';
          gsap.set(elements.rootCauseView, { opacity: 1, force3D: true });
          
          // Bot header stays visible - no animation needed, it persists
          if (rcBotHeader) {
            gsap.set(rcBotHeader, { opacity: 1, y: 0, force3D: true });
          }
          
          // Set all content (except bot header) to invisible initially
          // Note: rcItems container stays visible, only its children animate
          [rcAlert, rcBox, rcButton, rcActions, rcFeedback].forEach(el => {
            if (el) gsap.set(el, { opacity: 0, y: 8, force3D: true });
          });
          // Ensure rc-items are built and visible, but children start invisible
          buildRootCauseStatic();
          if (rcItems) {
            gsap.set(rcItems, { opacity: 1, y: 0, force3D: true });
            const rcItemElements = rcItems.querySelectorAll('.rc-item');
            rcItemElements.forEach(item => {
              gsap.set(item, { opacity: 0, y: 8, force3D: true });
            });
          }
        }
      }, "+=0.6");

      // Phase 6: cascade in root cause content section by section - snappy, immediate sequence
      // Animate each section in sequence using timeline methods
      if (rcAlert) {
        mainTimeline.to(rcAlert, {
          opacity: 1,
          y: 0,
          duration: 0.25,
          ease: 'power1.out'
        }, "+=0.1");
      }
      
      if (rcBox) {
        mainTimeline.to(rcBox, {
          opacity: 1,
          y: 0,
          duration: 0.25,
          ease: 'power1.out'
        }, "+=0.05");
      }
      
      if (rcButton) {
        mainTimeline.to(rcButton, {
          opacity: 1,
          y: 0,
          duration: 0.25,
          ease: 'power1.out'
        }, "+=0.05");
      }
      
      if (rcItems) {
        const rcItemElements = rcItems.querySelectorAll('.rc-item');
        if (rcItemElements.length > 0) {
          rcItemElements.forEach(item => {
            gsap.set(item, { scale: 0.95, force3D: true });
          });
          mainTimeline.to(rcItemElements, {
            opacity: 1,
            y: 0,
            scale: 1,
            duration: 0.25,
            stagger: 0.02,
            ease: 'back.out(1.1)'
          }, "+=0.05");
        } else {
          // If items haven't been built yet, ensure they're built and visible
          buildRootCauseStatic();
          const rcItemElementsAfter = rcItems.querySelectorAll('.rc-item');
          if (rcItemElementsAfter.length > 0) {
            rcItemElementsAfter.forEach(item => {
              gsap.set(item, { opacity: 0, y: 8, scale: 0.95, force3D: true });
            });
            mainTimeline.to(rcItemElementsAfter, {
              opacity: 1,
              y: 0,
              scale: 1,
              duration: 0.25,
              stagger: 0.02,
              ease: 'back.out(1.1)'
            }, "+=0.05");
          }
        }
      }
      
      if (rcActions) {
        mainTimeline.to(rcActions, {
          opacity: 1,
          y: 0,
          duration: 0.25,
          ease: 'power1.out'
        }, "+=0.05");
      }
      
      if (rcFeedback) {
        mainTimeline.to(rcFeedback, {
          opacity: 1,
          y: 0,
          duration: 0.25,
          ease: 'power1.out'
        }, "+=0.05");
      }

      // Phase 7: first card (right card) - start almost immediately after last rc-item
      mainTimeline.to(elements.cardRight, {
        opacity: 1,
        scale: 1,
        y: 0,
        rotation: 3,
        duration: 0.7,
        ease: "back.out(1.2)",
        onComplete: () => elements.cardRight.classList.add('shadow-final')
      }, "-=0.15"); // Start before rcFeedback finishes, overlapping with last items
      
      // Animate card header (profile block) in first
      const cardRightHeader = elements.cardRight.querySelector('.card-header');
      if (cardRightHeader) {
        mainTimeline.to(cardRightHeader, {
          opacity: 1,
          y: 0,
          duration: 0.4,
          ease: "power1.out"
        }, '<');
      }
      
      // Type text word-by-word (1.6 seconds)
      const rightTextTimeline = typeText(elements.cardRightText, cardMessages.right, 1.6);
      mainTimeline.add(rightTextTimeline, "+=0.2");
      
      // Animate reaction bubbles one by one - start immediately after text finishes
      const rightBubbles = elements.cardRightReaction.querySelectorAll('.reaction-bubble');
      rightBubbles.forEach((bubble, i) => {
        mainTimeline.from(bubble, {
          opacity: 0,
          scale: 0,
          duration: 0.3,
          ease: "back.out(1.7)"
        }, `+=${i === 0 ? 0.05 : 0.1}`); // First emoji starts almost immediately after text, second shortly after
      });
      mainTimeline.to(elements.cardRightReaction, { opacity: 1, duration: 0.01 }, '<');

      // Phase 8: second card (left card - starts as first card's first emoji appears)
      mainTimeline.to(elements.cardLeft, {
        opacity: 1,
        scale: 1,
        y: 0,
        rotation: -4,
        duration: 0.7,
        ease: "back.out(1.2)",
        onComplete: () => elements.cardLeft.classList.add('shadow-final')
      }, "-=0.3"); // Start as first emoji appears (0.3s before first emoji finishes, creating overlap)
      
      // Animate card header (profile block) in first
      const cardHeader = elements.cardLeft.querySelector('.card-header');
      if (cardHeader) {
        mainTimeline.to(cardHeader, {
          opacity: 1,
          y: 0,
          duration: 0.4,
          ease: "power1.out"
        }, '<');
      }
      
      // Then type text word-by-word
      mainTimeline.add(typeText(elements.cardLeftText, cardMessages.left, 1.6), "+=0.2");
      
      // Animate reaction bubbles one by one - start immediately after text finishes
      const leftBubbles = elements.cardLeftReaction.querySelectorAll('.reaction-bubble');
      leftBubbles.forEach((bubble, i) => {
        mainTimeline.from(bubble, {
          opacity: 0,
          scale: 0,
          duration: 0.3,
          ease: "back.out(1.7)"
        }, `+=${i === 0 ? 0.05 : 0.1}`); // Start almost immediately after text finishes
      });
      mainTimeline.to(elements.cardLeftReaction, { opacity: 1, duration: 0.01 }, '<');

      // Phase 9: settle + gentle outro
      mainTimeline.to([elements.cardRight, elements.cardLeft], {
        opacity: 0,
        scale: 0.9,
        y: 80,
        rotation: 0,
        duration: 0.5,
        stagger: 0.2,
        ease: 'power1.inOut'
      }, "+=2.2");

      mainTimeline.to(elements.rootCauseView, {
        opacity: 0,
        duration: 0.4,
        ease: 'power1.inOut'
      }, "+=0.6");
    }

    // Start animation when page loads
    window.addEventListener('load', () => {
      try {
        setupVisibilityControls();
        runAnimation();
      } catch (error) {
        console.error('Animation setup error:', error);
        embedIsInView = true;
        runAnimation();
      }
    });
  </script>
</body>
</html>
